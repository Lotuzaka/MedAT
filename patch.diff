 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -8,85 +8,89 @@ import com.zaxxer.hikari.HikariDataSource;
 import javax.swing.*;
 import javax.swing.border.EmptyBorder;
 import javax.swing.event.*;
 import javax.swing.plaf.basic.*;
 import javax.swing.table.*;
 import java.awt.*;
 import java.awt.event.*;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.URL;
 import java.sql.*;
 import java.util.*;
 import java.util.List;
 
 public class MedatoninDB extends JFrame {
 
     /* ------------------------------------------------------------- CONSTANTS */
 
     private static final Color CLR_BG = Color.WHITE,
             CLR_BTN_DEFAULT = new Color(188, 188, 188),
             CLR_BTN_ACCENT = new Color(0, 153, 76),
             CLR_BTN_DELETE = new Color(166, 28, 60),
             CLR_Q_ROW = new Color(178, 209, 255),
             CLR_ANS_OK = new Color(0, 153, 76, 75),
             CLR_BLUE_MED = new Color(1, 38, 65);
+
+    // Default vertical spacing between buttons (categories and subcategories)
+    private static final int BUTTON_SPACING = 5;
     private static final Font FONT_BASE = new Font("SansSerif", Font.PLAIN, 14),
             FONT_BOLD = FONT_BASE.deriveFont(Font.BOLD);
 
     /* ------------------------------------------------------------- FIELDS */
 
     // DB
     private Connection conn;
     private QuestionDAO questionDAO;
     private OptionDAO optionDAO;
     private testSimulationDAO simulationDAO;
 
     private String currentUsername; // To store the logged-in username
     // Store sub-databases for each category
     private Map<String, Map<String, DefaultTableModel>> categoryModels = new HashMap<>();;
     private Map<String, List<String>> subcategoryOrder = new HashMap<>();
 
     private JTable questionTable; // Table to hold questions and checkboxes
     private DefaultTableModel tableModel; // Table model for adding rows
     private JLabel userTextField; // Haupt-Textfeld for real-time editing
 
     private String currentCategory = "Biologie", currentSubcategory = ""; // Track the current subcategory
     private JButton printCategoryButton; // Button that will dynamically change label
     private JButton bioButton, chemButton, physButton, mathButton, kffButton; // Category buttons
     private JPanel subcategoryPanel; // Panel to hold subcategory buttons
     private JButton selectedSubcategoryButton = null; // Class-level variable to keep track of the currently selected
                                                       // subcategory button
 
     private Map<JTable, Integer> tablePendingDeleteRowMap = new HashMap<>(); // Track pending delete row per table
     private ImageIcon gearIcon; // Load the gear icon
     private ImageIcon penIcon; // Load the pen icon
     private ImageIcon penEditIcon; // Load the pen edit icon
 
     private boolean isEditMode = false; // Variable to check if edit mode is enabled
     private Point initialClickPoint; // Initial click point for the drag
     private JButton draggedButton; // Reference to the button being dragged
+    private JPanel draggedContainer; // Panel that contains the dragged button
     private int originalIndex = -1; // Original index of the dragged button
     private int dragThreshold = 5; // Threshold in pixels to start dragging
     private boolean isDragging = false; // Indicates if a drag operation is in progress
     private int lastTargetIndex = -1; // **Declaration of lastTargetIndex**
     private Set<QuestionIdentifier> pendingDeleteQuestions = new HashSet<>();
     private boolean isAdjustingFormat = false;
 
     // Panel to visually separate subcategories
     private JPanel mainContentPanel;
     JButton editToggleButton;
     private JButton addSubcategoryButton; // Declare this as a class member
     private Color backgroundColor = Color.WHITE;
     private int buttonBorderRadius = 7;
 
     // Dropdown to select test simulations
     private JComboBox<String> simulationComboBox;
     private Map<String, Integer> simulationMap; // Maps simulation names to their IDs
     private Integer selectedSimulationId = null; // ID der ausgewählten Simulation
 
     public MedatoninDB() throws SQLException {
         HikariConfig cfg = new HikariConfig();
         cfg.setJdbcUrl("jdbc:mysql://localhost:3306/medatonindb");
         cfg.setUsername("root");
         cfg.setPassword("288369Ma;");
         HikariDataSource ds = new HikariDataSource(cfg);
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -486,52 +490,52 @@ public class MedatoninDB extends JFrame {
         getContentPane().removeAll();
         getContentPane().revalidate();
         getContentPane().repaint();
 
         // Create and show the login window again
         createLoginWindow();
     }
 
     private void resetState() {
         // Reset any state variables or clear data as needed
         categoryModels.clear();
         currentCategory = null;
         // Add any other state resets here
     }
 
     // Modify the setEditMode method to handle the spacing change between
     // subcategory buttons
     private void setEditMode(boolean editMode) {
         isEditMode = editMode;
         if (isEditMode) {
             System.out.println("Edit mode enabled");
             // Set the spacing between subcategory buttons to zero
             adjustSubcategoryButtonSpacing(0);
         } else {
             System.out.println("Normal mode enabled");
-            // Restore the normal spacing between subcategory buttons
-            adjustSubcategoryButtonSpacing(5); // Adjust the value as needed to match the normal spacing
+            // Restore the normal spacing using the shared spacing constant
+            adjustSubcategoryButtonSpacing(BUTTON_SPACING);
             updateSubcategoryOrder(); // Save the order when exiting edit mode
         }
     }
 
     // Populate ComboBox with simulations
     private void loadSimulationOptions() {
         // Populate the simulation combo box with available simulations
         simulationComboBox.removeAllItems();
         simulationComboBox.addItem("Haupt-Datenbank"); // Add the default option for the general pool
         this.simulationDAO = new testSimulationDAO(conn);
         List<testSimulationDAO> simulations = null;
         try {
             simulations = simulationDAO.getAllSimulations();
         } catch (SQLException e1) {
             e1.printStackTrace();
         }
         for (testSimulationDAO simulation : simulations) {
             simulationComboBox.addItem(simulation.getName());
             simulationMap.put(simulation.getName(), simulation.getId());
         }
         simulationComboBox.addItem("+"); // Add the "Create" option
     }
 
     // Method to adjust the spacing between subcategory buttons dynamically
     private void adjustSubcategoryButtonSpacing(int spacing) {
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -553,52 +557,58 @@ public class MedatoninDB extends JFrame {
                     switchSubcategory(currentCategory, subcategory);
                 }
             });
 
             buttonContainer.add(subButton);
 
             // Minus-Button nur im Bearbeitungsmodus
             if (isEditMode) {
                 buttonContainer.add(Box.createHorizontalStrut(5)); // Kleiner Abstand
 
                 JButton deleteButton = new JButton("-");
                 deleteButton.setPreferredSize(new Dimension(30, 25));
                 deleteButton.setMaximumSize(new Dimension(30, 25));
                 deleteButton.setBackground(new Color(211, 47, 47)); // Rot
                 deleteButton.setForeground(Color.WHITE);
                 deleteButton.setFont(new Font("Arial", Font.BOLD, 16));
                 deleteButton.setFocusPainted(false);
                 deleteButton.setBorderPainted(false);
                 deleteButton.setOpaque(true);
 
                 deleteButton.addActionListener(e -> deleteSubcategory(currentCategory, subcategory));
 
                 buttonContainer.add(deleteButton);
             }
 
+            // Limit growth so spacing stays consistent when resizing
+            buttonContainer.setMaximumSize(new Dimension(Integer.MAX_VALUE,
+                    buttonContainer.getPreferredSize().height));
+
             subcategoryPanel.add(buttonContainer);
-            subcategoryPanel.add(Box.createVerticalStrut(5)); // Immer gleicher Abstand
+            if (spacing > 0) {
+                subcategoryPanel.add(Box.createVerticalStrut(spacing));
+            }
         }
 
         // "+" Button am Ende hinzufügen (nur im Bearbeitungsmodus)
         if (isEditMode) {
             addSubcategoryButton = createModernButton("+");
             addSubcategoryButton.setBackground(new Color(0, 153, 76));
             addSubcategoryButton.addActionListener(e -> addNewSubcategory(currentCategory));
             subcategoryPanel.add(addSubcategoryButton);
         }
 
         subcategoryPanel.revalidate();
         subcategoryPanel.repaint();
     }
 
     private void deleteSubcategory(String category, String subcategoryName) {
         List<String> orderList = subcategoryOrder.get(category);
 
         if (orderList != null && orderList.size() > 1) {
             int confirmation = JOptionPane.showConfirmDialog(this,
                     "Are you sure you want to delete subcategory: " + subcategoryName + "?",
                     "Confirm Delete",
                     JOptionPane.YES_NO_OPTION);
 
             if (confirmation == JOptionPane.YES_OPTION) {
                 // Remove the subcategory and update the order list
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -611,147 +621,167 @@ public class MedatoninDB extends JFrame {
                     JOptionPane.showMessageDialog(this, "Subcategory deleted successfully.",
                             "Success", JOptionPane.INFORMATION_MESSAGE);
                 } else {
                     JOptionPane.showMessageDialog(this, "Failed to delete subcategory from database.",
                             "Error", JOptionPane.ERROR_MESSAGE);
                 }
             }
         } else {
             JOptionPane.showMessageDialog(this, "At least one subcategory must exist.",
                     "Error", JOptionPane.ERROR_MESSAGE);
         }
     }
 
     // Function to add drag-and-drop functionality to subcategory buttons
     private void addDragAndDropFunctionality(JButton button, JPanel subcategoryPanel) {
         button.setFocusable(false); // Disable focusability for better user experience
 
         button.addMouseListener(new MouseAdapter() {
             @Override
             public void mousePressed(MouseEvent e) {
                 if (isEditMode) {
                     initialClickPoint = e.getPoint();
                     isDragging = false; // Not yet dragging
                     originalIndex = getButtonIndex(button);
                     draggedButton = button;
+                    draggedContainer = (JPanel) button.getParent();
                     lastTargetIndex = originalIndex; // Initialize lastTargetIndex
                 }
             }
 
             @Override
             public void mouseReleased(MouseEvent e) {
                 if (isEditMode && isDragging) {
                     isDragging = false;
                     // Reset visual feedback
                     resetButtonAppearance(draggedButton);
 
+                    draggedContainer = null;
+
                     // Update subcategoryOrder
                     updateSubcategoryOrder();
                     button.setForeground(Color.BLACK);
                     subcategoryPanel.revalidate();
                     subcategoryPanel.repaint();
                 }
             }
         });
 
         button.addMouseMotionListener(new MouseMotionAdapter() {
             @Override
             public void mouseDragged(MouseEvent e) {
                 if (isEditMode) {
                     if (!isDragging) {
                         Point dragPoint = e.getPoint();
                         int distance = Math.abs(dragPoint.y - initialClickPoint.y);
                         if (distance > dragThreshold) {
                             // Start dragging
                             isDragging = true;
 
                             // Visual feedback: make the button 70% size and semi-transparent
                             // draggedButton.setBorder(BorderFactory.createDashedBorder(Color.BLACK, 1, 5));
                             draggedButton.setPreferredSize(
                                     new Dimension((int) (button.getWidth() * 0.3), (int) (button.getHeight() * 0.3)));
                             draggedButton.setAlignmentX(Component.LEFT_ALIGNMENT);
                             draggedButton.setOpaque(false);
                             draggedButton.setForeground(Color.RED);
                         }
                     }
 
                     if (isDragging) {
                         subcategoryPanel.validate(); // Ensure component bounds are up to date
                         int targetIndex = getIndexForPoint(e);
 
                         // Only update if targetIndex has significantly changed
                         if (targetIndex != lastTargetIndex && targetIndex >= 0
                                 && targetIndex < subcategoryPanel.getComponentCount()) {
                             // Remove and re-add the button at the new index
-                            subcategoryPanel.remove(draggedButton);
-                            subcategoryPanel.add(draggedButton, targetIndex);
+                            subcategoryPanel.remove(draggedContainer);
+                            subcategoryPanel.add(draggedContainer, targetIndex);
 
                             lastTargetIndex = targetIndex;
 
                             subcategoryPanel.revalidate();
                             subcategoryPanel.repaint();
                         }
                     }
                 }
             }
         });
     }
 
     // Helper method to reset button appearance after dragging
     private void resetButtonAppearance(JButton button) {
         button.setPreferredSize(null);
         button.setAlignmentX(Component.LEFT_ALIGNMENT);
         // Reset the border to maintain spacing
         button.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10)); // top, left, bottom, right
         button.setOpaque(true);
     }
 
     // Helper method to get the index of a button in subcategoryPanel
     private int getButtonIndex(JButton button) {
         Component[] components = subcategoryPanel.getComponents();
         for (int index = 0; index < components.length; index++) {
-            if (components[index] == button) {
+            Component comp = components[index];
+            if (comp == button) {
                 return index;
             }
+            if (comp instanceof JPanel) {
+                JPanel panel = (JPanel) comp;
+                for (Component inner : panel.getComponents()) {
+                    if (inner == button) {
+                        return index;
+                    }
+                }
+            }
         }
         return -1; // Should not happen
     }
 
     // Helper method to get the index for a given mouse event
     private int getIndexForPoint(MouseEvent e) {
         Point panelPoint = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), subcategoryPanel);
         int mouseY = panelPoint.y;
 
         Component[] components = subcategoryPanel.getComponents();
         int index = 0;
         for (Component comp : components) {
-            if (comp == draggedButton) {
+            if (comp == draggedContainer) {
                 continue;
             }
-            if (comp instanceof JButton) {
-                JButton btn = (JButton) comp;
-                if (btn.getText().equals("+")) {
+            JButton btn = null;
+            if (comp instanceof JPanel) {
+                Component[] inner = ((JPanel) comp).getComponents();
+                if (inner.length > 0 && inner[0] instanceof JButton) {
+                    btn = (JButton) inner[0];
+                }
+            } else if (comp instanceof JButton) {
+                btn = (JButton) comp;
+            }
+            if (btn != null) {
+                if ("+".equals(btn.getText())) {
                     break; // Do not place before the '+' button
                 }
                 Rectangle bounds = comp.getBounds();
                 int componentMiddleY = bounds.y + bounds.height / 2;
                 if (mouseY < componentMiddleY) {
                     return index;
                 }
                 index++;
             }
         }
         return index;
     }
 
     // Method to update the subcategory order after rearrangement
     private void updateSubcategoryOrder() {
         List<String> orderList = new ArrayList<>();
         for (Component comp : subcategoryPanel.getComponents()) {
             if (comp instanceof JPanel) {
                 Component[] inner = ((JPanel) comp).getComponents();
                 if (inner.length > 0 && inner[0] instanceof JButton) {
                     String text = ((JButton) inner[0]).getText();
                     orderList.add(text);
                 }
             } else if (comp instanceof JButton) {
                 // in case buttons are added directly (e.g., '+') skip them
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -765,51 +795,51 @@ public class MedatoninDB extends JFrame {
         subcategoryOrder.put(currentCategory, orderList);
 
         // Save the new order to the database
         saveSubcategoryOrderToDatabase(currentCategory, orderList);
     }
 
     private void saveSubcategoryOrderToDatabase(String category, List<String> orderList) {
         String updateSql = "UPDATE subcategories SET order_index = ? WHERE name = ? AND category_id = (SELECT id FROM categories WHERE name = ?)";
         try (PreparedStatement stmt = conn.prepareStatement(updateSql)) {
             for (int i = 0; i < orderList.size(); i++) {
                 stmt.setInt(1, i);
                 stmt.setString(2, orderList.get(i));
                 stmt.setString(3, category);
                 stmt.addBatch();
             }
             stmt.executeBatch();
             System.out.println("Subcategory order updated in database for category: " + category);
         } catch (SQLException e) {
             e.printStackTrace();
         }
     }
 
     // Method to add a button to the panel with spacing automatically
     private void addButtonWithSpacing(JPanel panel, JButton button) {
         panel.add(button);
-        panel.add(Box.createVerticalStrut(5)); // Automatically add spacing after each button
+        panel.add(Box.createVerticalStrut(BUTTON_SPACING)); // spacing controlled by constant
     }
 
     // Helper method to create a category with subcategories
     private void createCategoryModel(String category) {
         System.out.println("Creating category model for: " + category); // Debug log
 
         if (category == null) {
             System.out.println("Error: Category is null");
             return;
         }
 
         int categoryId = getCategoryID(category);
         if (categoryId == -1) {
             System.out.println("Error: Invalid category ID for category: " + category);
             return;
         }
 
         Map<String, DefaultTableModel> subcategories = loadSubcategoriesFromDatabase(categoryId);
         if (subcategories == null) {
             System.out.println("Error: Failed to load subcategories for category: " + category);
             subcategories = new HashMap<>(); // Create an empty map to avoid null pointer exceptions
         }
 
         if (categoryModels == null) {
             System.out.println("Error: categoryModels is null");
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -832,95 +862,97 @@ public class MedatoninDB extends JFrame {
         // Load questions for all subcategories
         loadQuestionsFromDatabase(category, subcategories, selectedSimulationId);
     }
 
     // Method to load subcategories and place buttons in the panel
     private void loadSubcategories(String category) {
         subcategoryPanel.removeAll();
         subcategoryPanel.setLayout(new BoxLayout(subcategoryPanel, BoxLayout.Y_AXIS));
         subcategoryPanel.setBackground(backgroundColor);
 
         List<String> orderList = subcategoryOrder.get(category);
         Color subcategoryBackgroundColor = getCategoryButtonColor(category);
 
         if (orderList != null) {
             for (String subcategory : orderList) {
                 // Container für Button und Minus-Button"-
                 JPanel buttonContainer = new JPanel();
                 buttonContainer.setLayout(new BoxLayout(buttonContainer, BoxLayout.X_AXIS));
                 buttonContainer.setBackground(backgroundColor);
                 buttonContainer.setAlignmentX(Component.LEFT_ALIGNMENT);
                 buttonContainer.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));
 
                 JButton subButton = createModernButton(subcategory);
 
                 if (isEditMode) {
-                    addDragAndDropFunctionality(subButton, buttonContainer); // Achtung: buttonContainer statt
-                                                                             // subcategoryPanel
+                    addDragAndDropFunctionality(subButton, subcategoryPanel);
                 }
 
                 subButton.addActionListener(e -> {
                     if (!isEditMode) {
                         switchSubcategory(category, subcategory);
                         subButton.setBackground(subcategoryBackgroundColor);
                     }
                 });
 
                 // Right-click to edit text
                 subButton.addMouseListener(new MouseAdapter() {
                     @Override
                     public void mousePressed(MouseEvent e) {
                         if (SwingUtilities.isRightMouseButton(e) && isEditMode) {
                             showSubcategoryMenu(e, subButton, category);
                         }
                     }
                 });
 
                 buttonContainer.add(subButton);
 
                 // Minus-Button nur im Bearbeitungsmodus
                 if (isEditMode) {
                     buttonContainer.add(Box.createHorizontalStrut(5));
 
                     JButton deleteButton = new JButton("-");
                     deleteButton.setPreferredSize(new Dimension(30, 25));
                     deleteButton.setMaximumSize(new Dimension(30, 25));
                     deleteButton.setMinimumSize(new Dimension(30, 25));
                     deleteButton.setBackground(new Color(211, 47, 47));
                     deleteButton.setForeground(Color.WHITE);
                     deleteButton.setFont(new Font("Arial", Font.BOLD, 14));
                     deleteButton.setFocusPainted(false);
                     deleteButton.setBorderPainted(false);
                     deleteButton.setOpaque(true);
 
                     deleteButton.addActionListener(e -> deleteSubcategory(category, subcategory));
 
                     buttonContainer.add(deleteButton);
                 }
 
                 subcategoryPanel.add(buttonContainer);
-                subcategoryPanel.add(Box.createVerticalStrut(0));
+                int spacing = isEditMode ? 0 : BUTTON_SPACING;
+                if (spacing > 0) {
+                    subcategoryPanel.add(Box.createVerticalStrut(spacing));
+                }
             }
         }
 
         // "+" Button nur im Bearbeitungsmodus
         if (isEditMode) {
             addSubcategoryButton = createModernButton("+");
             addSubcategoryButton.setBackground(new Color(0, 153, 76));
             addSubcategoryButton.addActionListener(e -> addNewSubcategory(category));
             subcategoryPanel.add(addSubcategoryButton);
         }
 
         subcategoryPanel.revalidate();
         subcategoryPanel.repaint();
 
         displaySubcategoriesInMainContent(category);
     }
 
     // Method to get the corresponding background color of the category buttons
     private Color getCategoryButtonColor(String category) {
         if (category == null) {
             return new Color(188, 188, 188); // Default color when category is null
         }
         switch (category) {
             case "Biologie":
                 return new Color(231, 167, 16); // Orange background for Biologie
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -2127,50 +2159,60 @@ public class MedatoninDB extends JFrame {
                 return i;
             }
         }
         return -1; // Column not found
     }
 
     // Update the print button label based on the current category and subcategory
     // names
     private void updatePrintButtonLabel() {
         String printButtonText = currentCategory /*
                                                   * + (currentSubcategory.isEmpty() ? "" : " - " + currentSubcategory)
                                                   */
                 + " Print";
         printCategoryButton.setText(printButtonText);
         adjustPrintButtonWidth(printCategoryButton, printButtonText);
     }
 
     // Method to get the subcategory button by its text
     private JButton getSubcategoryButton(String subcategory) {
         for (Component component : subcategoryPanel.getComponents()) {
             if (component instanceof JButton) {
                 JButton button = (JButton) component;
                 if (button.getText().equals(subcategory)) {
                     return button;
                 }
+            } else if (component instanceof JPanel) {
+                JPanel panel = (JPanel) component;
+                for (Component innerComp : panel.getComponents()) {
+                    if (innerComp instanceof JButton) {
+                        JButton button = (JButton) innerComp;
+                        if (button.getText().equals(subcategory)) {
+                            return button;
+                        }
+                    }
+                }
             }
         }
         return null; // Return null if no matching button is found
     }
 
     // Adjust column widths for a given table
     private void adjustColumnWidths(JTable table) {
         if (table != null && table.getColumnModel().getColumnCount() > 0) {
             // Adjust "Nr." column width
             TableColumn nrColumn = table.getColumnModel().getColumn(0);
             nrColumn.setMinWidth(40); // Min width
             nrColumn.setMaxWidth(40); // Max width
             nrColumn.setPreferredWidth(40); // Preferred width
 
             // Adjust "Korrekt" (✓) column width
             TableColumn korrektColumn = table.getColumnModel().getColumn(2);
             korrektColumn.setMinWidth(40); // Min width
             korrektColumn.setMaxWidth(50); // Max width
             korrektColumn.setPreferredWidth(50); // Preferred width
 
             // Adjust "Set" column width
             TableColumn actionColumn = table.getColumnModel().getColumn(3);
             actionColumn.setMinWidth(35); // Min width
             actionColumn.setMaxWidth(35); // Max width
             actionColumn.setPreferredWidth(35); // Preferred width
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 326cf5e5002ceeea7f260204bf084e8eb41234fb..c1c8b9c411fd8a41b98f07952bacd18435e43c15 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -3002,51 +3044,52 @@ public class MedatoninDB extends JFrame {
             QuestionIdentifier identifier = new QuestionIdentifier(currentSubcategory,
                     Integer.parseInt(questionNumber));
 
             if (pendingDeleteQuestions.contains(identifier)) {
                 // Second click - delete without confirmation
                 deleteQuestionAtRow(questionTable, row);
                 pendingDeleteQuestions.remove(identifier);
             } else {
                 // First click - highlight the question
                 pendingDeleteQuestions.add(identifier);
             }
 
             questionTable.repaint();
         }
 
         @Override
         public Object getCellEditorValue() {
             if (editingColumn == 2) {
                 if (editorComponent == deleteButton) {
                     return "X";
                 } else if (editorComponent == checkBox) {
                     return checkBox.isSelected();
                 }
             } else if (editingColumn == 4 && editorComponent == difficultyCombo) {
                 return difficultyCombo.getSelectedItem(); // Das ist schon korrekt
-            } else if (editorComponent == defaultTextEditor) {
+            } else if (editorComponent instanceof JTextField) {
+                // Always delegate to the default text editor for text fields
                 return defaultTextEditor.getCellEditorValue();
             }
             return "";
         }
 
         @Override
         public Component getTableCellEditorComponent(JTable table, Object value,
                 boolean isSelected, int row, int column) {
             this.questionTable = table;
             this.editingRow = row;
             this.editingColumn = column;
 
             // Handle the options row for "Figuren"
             if ("Figuren".equals(currentSubcategory)) {
                 Object cellValue = table.getModel().getValueAt(row, column);
                 if (cellValue instanceof List<?>) {
                     // Options row in "Figuren" is not editable
                     return null;
                 }
             }
 
             if (column == 2) {
                 if (isFrageRow(row, (DefaultTableModel) table.getModel())) {
                     // For question rows, use delete button
                     deleteButton.setForeground(Color.RED);
 
EOF
)