 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/pom.xml b/pom.xml
index af129376e91975af81bb0b547c4c5a1bc1e1972e..4b46133bc8c506313362efefd753c0194ad86b41 100644
--- a/pom.xml
+++ b/pom.xml
@@ -57,50 +57,69 @@
 
     <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.33</version>
     </dependency>
   
     <dependency>
       <groupId>org.apache.derby</groupId>
       <artifactId>derby</artifactId>
       <version>10.17.1.0</version>
     </dependency>
     
     <dependency>
         <groupId>com.zaxxer</groupId>
         <artifactId>HikariCP</artifactId>
         <version>3.4.5</version>
     </dependency>
 
     <dependency>
       <groupId>org.locationtech.jts</groupId>
       <artifactId>jts-core</artifactId>
       <version>1.20.0</version>
     </dependency>
 
+    <!-- docx4j for advanced WordprocessingML handling -->
+    <dependency>
+      <groupId>org.docx4j</groupId>
+      <artifactId>docx4j</artifactId>
+      <version>8.3.7</version>
+    </dependency>
+
+    <!-- JAXB dependencies required for docx4j on Java 11+ -->
+    <dependency>
+      <groupId>jakarta.xml.bind</groupId>
+      <artifactId>jakarta.xml.bind-api</artifactId>
+      <version>2.3.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.glassfish.jaxb</groupId>
+      <artifactId>jaxb-runtime</artifactId>
+      <version>2.3.3</version>
+    </dependency>
+
   </dependencies>
 
 
   <build>
     <plugins>
       <!-- Maven JAR Plugin -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
         <version>3.1.2</version>
         <configuration>
           <archive>
             <manifestEntries>
               <Main-Class>MedatoninDB</Main-Class> <!-- Replace with the correct package name -->
             </manifestEntries>
           </archive>
         </configuration>
       </plugin>
 
       <!-- Maven Shade Plugin -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
         <version>3.2.4</version>
         <executions>
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index b766cd49a1415a814314fb0fb477aa80d6857e25..756d37abe20d74b4483113f43b55f484ec1d3066 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -1,41 +1,43 @@
 import dao.AllergyCardDAO;
 import model.AllergyCardData;
 import org.apache.poi.xwpf.usermodel.*;
 import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSectPr;
 import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPageMar;
 import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr;
 import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSpacing;
 import org.openxmlformats.schemas.wordprocessingml.x2006.main.STLineSpacingRule;
 import org.locationtech.jts.geom.Geometry;
 import org.locationtech.jts.geom.Envelope;
 // import org.locationtech.jts.io.ParseException;
 import org.locationtech.jts.io.WKTReader;
 import org.locationtech.jts.io.WKTWriter;
 import org.locationtech.jts.awt.ShapeWriter;
 import com.zaxxer.hikari.HikariConfig;
 import com.zaxxer.hikari.HikariDataSource;
+import docx.Docx4jPrinter;
+import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.plaf.basic.*;
 import javax.swing.table.*;
 import java.awt.*;
 import java.awt.event.*;
 import java.awt.geom.AffineTransform;
 import java.awt.image.BufferedImage;
 import javax.imageio.ImageIO;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.sql.*;
 import java.util.*;
 import java.util.List;
 import java.math.BigInteger;
 
 // import java.io.BufferedWriter; // No longer needed
 // import java.io.OutputStreamWriter; // No longer needed
 
@@ -107,50 +109,68 @@ public class MedatoninDB extends JFrame {
         
         for (String preferred : preferredFonts) {
             for (String available : availableFonts) {
                 if (available.equals(preferred)) {
                     return preferred;
                 }
             }
         }
         return "SansSerif"; // Fallback
     }
 
     /* ------------------------------------------------------------- FIELDS */
 
     // DB
     private Connection conn;
     private QuestionDAO questionDAO;
     private OptionDAO optionDAO;
     private testSimulationDAO simulationDAO;
     private HikariDataSource ds; // Store datasource for proper lifecycle
 
     private String currentUsername; // To store the logged-in username
     // Store sub-databases for each category
     private Map<String, Map<String, DefaultTableModel>> categoryModels = new HashMap<>();;
     private Map<String, List<String>> subcategoryOrder = new HashMap<>();
 
+    // Mapping of category or subcategory names to introduction page index
+    private static final Map<String, Integer> INTRO_PAGE_INDEX = Map.ofEntries(
+            Map.entry("Biologie", 0),
+            Map.entry("Chemie", 1),
+            Map.entry("Physik", 2),
+            Map.entry("Mathematik", 3),
+            Map.entry("Textverständnis", 4),
+            Map.entry("Figuren Zusammensetzen", 5),
+            Map.entry("Gedächtnis und Merkfähigkeit (Lernphase)", 6),
+            Map.entry("Zahlenfolgen", 7),
+            Map.entry("Wortflüssigkeit", 8),
+            Map.entry("Gedächtnis und Merkfähigkeit (Abrufphase)", 9),
+            Map.entry("Implikationen erkennen", 10),
+            Map.entry("Emotionen regulieren", 11),
+            Map.entry("Emotionen erkennen", 12),
+            Map.entry("Soziales entscheiden", 13)
+    );
+
     private JTable questionTable; // Table to hold questions and checkboxes
     private DefaultTableModel tableModel; // Table model for adding rows
     private JLabel userTextField; // Haupt-Textfeld for real-time editing
 
     private String currentCategory = "Biologie", currentSubcategory = ""; // Track the current subcategory
     private JButton printCategoryButton; // Button that will dynamically change label
     private JButton bioButton, chemButton, physButton, mathButton, kffButton; // Category buttons
     private JPanel subcategoryPanel; // Panel to hold subcategory buttons
     private JButton selectedSubcategoryButton = null; // Class-level variable to keep track of the currently selected
                                                       // subcategory button
 
     private Map<JTable, Integer> tablePendingDeleteRowMap = new HashMap<>(); // Track pending delete row per table
     private ImageIcon gearIcon; // Load the gear icon
     private ImageIcon penIcon; // Load the pen icon
     private ImageIcon penEditIcon; // Load the pen edit icon
 
     private boolean isEditMode = false; // Variable to check if edit mode is enabled
     private Point initialClickPoint; // Initial click point for the drag
     private JButton draggedButton; // Reference to the button being dragged
     private JPanel draggedContainer; // Panel that contains the dragged button
     private int originalIndex = -1; // Original index of the dragged button
     private int dragThreshold = 5; // Threshold in pixels to start dragging
     private boolean isDragging = false; // Indicates if a drag operation is in progress
     private int lastTargetIndex = -1; // **Declaration of lastTargetIndex**
     private Set<QuestionIdentifier> pendingDeleteQuestions = new HashSet<>();
@@ -3112,89 +3132,79 @@ public class MedatoninDB extends JFrame {
                 XWPFRun pageBreakRun = pageBreakParagraph.createRun();
                 pageBreakRun.addBreak(BreakType.PAGE);
             }
 
             // Add solutions directly without headings
             globalQuestionCount = addQuestionsToDocument(document, model, true, globalQuestionCount, subcategory);
             
             // Add stop sign page after each subcategory
             addStopSignPage(document);
         }
 
         // Save the document
         try (FileOutputStream out = new FileOutputStream(category + "_Solutions.docx")) {
             document.write(out);
             JOptionPane.showMessageDialog(this, "Solution document saved: " + category + "_Solutions.docx");
         } catch (IOException e) {
             e.printStackTrace();
             JOptionPane.showMessageDialog(this, "Error saving solution document: " + e.getMessage(), "Error",
                     JOptionPane.ERROR_MESSAGE);
         }
     }
 
     // Method to print all categories and their subcategories to a single Word
     // document
     private void printAllCategories() {
-        XWPFDocument document = new XWPFDocument();
-        
-        // Set up page margins
-        setupPageMargins(document);
-
-        // Use a global question counter for page breaks
-        int globalQuestionCount = 0;
-
-        // Iterate over all categories
-        for (String category : categoryModels.keySet()) {
-            Map<String, DefaultTableModel> subcategories = categoryModels.get(category);
-
-            // Iterate over subcategories without category/subcategory headings
-            for (String subcategory : subcategoryOrder.get(category)) {
-                DefaultTableModel model = subcategories.get(subcategory);
-                if (model == null || model.getRowCount() == 0) {
-                    continue; // Skip empty subcategories
+        try {
+            Docx4jPrinter printer = new Docx4jPrinter();
+            List<List<Object>> introPages = printer.loadIntroductionPages(new File("untertest_introductionPage.docx"));
+            WordprocessingMLPackage pkg = WordprocessingMLPackage.createPackage();
+
+            for (String category : categoryModels.keySet()) {
+                Integer catIndex = INTRO_PAGE_INDEX.get(category);
+                if (catIndex != null && catIndex < introPages.size()) {
+                    printer.appendPage(pkg, introPages.get(catIndex));
                 }
 
-                // Add page break before each subcategory (except the first one)
-                if (globalQuestionCount > 0) {
-                    XWPFParagraph pageBreakParagraph = document.createParagraph();
-                    XWPFRun pageBreakRun = pageBreakParagraph.createRun();
-                    pageBreakRun.addBreak(BreakType.PAGE);
-                }
+                Map<String, DefaultTableModel> subcats = categoryModels.get(category);
+                for (String subcat : subcategoryOrder.get(category)) {
+                    Integer pageIdx = INTRO_PAGE_INDEX.get(subcat);
+                    if (pageIdx != null && pageIdx < introPages.size()) {
+                        printer.appendPage(pkg, introPages.get(pageIdx));
+                    }
 
-                // Add questions directly without headings
-                globalQuestionCount = addQuestionsToDocument(document, model, false, globalQuestionCount, subcategory);
-                
-                // Add stop sign page after each subcategory
-                addStopSignPage(document);
+                    DefaultTableModel model = subcats.get(subcat);
+                    if (model != null && model.getRowCount() > 0) {
+                        printer.addQuestions(pkg, model);
+                        printer.addPageBreak(pkg);
+                    }
+                }
             }
-        }
 
-        // Save the document
-        try (FileOutputStream out = new FileOutputStream("All_Categories.docx")) {
-            document.write(out);
+            pkg.save(new File("All_Categories.docx"));
             JOptionPane.showMessageDialog(this, "Document saved: All_Categories.docx");
-        } catch (IOException e) {
+        } catch (Exception e) {
             e.printStackTrace();
             JOptionPane.showMessageDialog(this, "Error saving document: " + e.getMessage(), "Error",
                     JOptionPane.ERROR_MESSAGE);
         }
     }
 
     // Method to print all categories and their subcategories to a single solution
     // Word document
     private void printAllCategoriesSolution() {
         XWPFDocument document = new XWPFDocument();
         
         // Set up page margins
         setupPageMargins(document);
 
         // Use a global question counter for page breaks
         int globalQuestionCount = 0;
 
         // Iterate over all categories
         for (String category : categoryModels.keySet()) {
             Map<String, DefaultTableModel> subcategories = categoryModels.get(category);
 
             // Iterate over subcategories without category/subcategory headings
             for (String subcategory : subcategoryOrder.get(category)) {
                 DefaultTableModel model = subcategories.get(subcategory);
                 if (model == null || model.getRowCount() == 0) {
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5673b547cda42be148513c712ab860dfa083fa9
--- /dev/null
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -0,0 +1,113 @@
+package docx;
+
+import org.docx4j.openpackaging.exceptions.Docx4JException;
+import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
+import org.docx4j.wml.*;
+
+import javax.swing.table.DefaultTableModel;
+import java.io.File;
+import java.util.*;
+
+/**
+ * Utility class using docx4j to generate print documents. This is a very
+ * small proof of concept and does not cover the entire functionality of
+ * the original Apache POI implementation.
+ */
+public class Docx4jPrinter {
+
+    private final ObjectFactory factory = new ObjectFactory();
+
+    /**
+     * Load the introduction pages and split them by page breaks.
+     */
+    public List<List<Object>> loadIntroductionPages(File docx) throws Docx4JException {
+        WordprocessingMLPackage pkg = WordprocessingMLPackage.load(docx);
+        List<Object> content = pkg.getMainDocumentPart().getContent();
+        List<List<Object>> pages = new ArrayList<>();
+        List<Object> current = new ArrayList<>();
+        for (Object o : content) {
+            current.add(o);
+            if (containsPageBreak(o)) {
+                pages.add(new ArrayList<>(current));
+                current.clear();
+            }
+        }
+        if (!current.isEmpty()) {
+            pages.add(new ArrayList<>(current));
+        }
+        return pages;
+    }
+
+    private boolean containsPageBreak(Object o) {
+        if (o instanceof P p) {
+            for (Object c : p.getContent()) {
+                if (c instanceof Br br && br.getType() == STBrType.PAGE) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Create a document containing the introduction pages followed by question
+     * text. Images and advanced formatting are not handled here.
+     */
+    public WordprocessingMLPackage buildDocument(Map<String, DefaultTableModel> subcats,
+                                                 List<String> order,
+                                                 List<List<Object>> introPages) throws Docx4JException {
+        WordprocessingMLPackage pkg = WordprocessingMLPackage.createPackage();
+        int pageIndex = 0;
+        for (String subcat : order) {
+            if (pageIndex < introPages.size()) {
+                for (Object o : introPages.get(pageIndex)) {
+                    pkg.getMainDocumentPart().addObject(o);
+                }
+                pageIndex++;
+            }
+            DefaultTableModel model = subcats.get(subcat);
+            if (model != null) {
+                addQuestions(pkg, model);
+            }
+            addPageBreak(pkg);
+        }
+        return pkg;
+    }
+
+    /**
+     * Append the given question table to the document. Only basic text is
+     * exported; options and images are ignored for brevity.
+     */
+    public void addQuestions(WordprocessingMLPackage pkg, DefaultTableModel model) {
+        for (int r = 0; r < model.getRowCount(); r++) {
+            if (!"Frage".equals(model.getValueAt(r, 2))) continue; // simplistic check
+            String number = Objects.toString(model.getValueAt(r, 0), "");
+            String text = Objects.toString(model.getValueAt(r, 1), "");
+            P p = factory.createP();
+            R rObj = factory.createR();
+            Text t = factory.createText();
+            t.setValue(number + ". " + text);
+            rObj.getContent().add(t);
+            p.getContent().add(rObj);
+            pkg.getMainDocumentPart().addObject(p);
+        }
+    }
+
+    /** Add a page break to the document. */
+    public void addPageBreak(WordprocessingMLPackage pkg) {
+        P p = factory.createP();
+        Br br = factory.createBr();
+        br.setType(STBrType.PAGE);
+        p.getContent().add(br);
+        pkg.getMainDocumentPart().addObject(p);
+    }
+
+    /**
+     * Append the provided introduction page objects to the document.
+     */
+    public void appendPage(WordprocessingMLPackage pkg, List<Object> page) {
+        for (Object o : page) {
+            pkg.getMainDocumentPart().addObject(o);
+        }
+    }
+}
 
EOF
)