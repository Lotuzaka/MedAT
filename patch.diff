 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/main/java/generator/TextverstaendnisGenerator.java b/src/main/java/generator/TextverstaendnisGenerator.java
index a9ea4260bd937dd38519f2d5a696ebd35f1a5292..c1b5924fa982ec4a7bd3c3f36bb9b2ed7f58dacc 100644
--- a/src/main/java/generator/TextverstaendnisGenerator.java
+++ b/src/main/java/generator/TextverstaendnisGenerator.java
@@ -8,127 +8,160 @@ import edu.stanford.nlp.naturalli.NaturalLogicAnnotations;
 import edu.stanford.nlp.pipeline.Annotation;
 import edu.stanford.nlp.pipeline.StanfordCoreNLP;
 import edu.stanford.nlp.util.CoreMap;
 
 import java.io.*;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.*;
 
 /**
  * Enhanced Textverständnis Generator following AGENTS.md specifications.
  * Implements sophisticated question generation with advanced NLP processing,
  * systematic distractor creation, and difficulty grading.
  */
 public class TextverstaendnisGenerator {
 
     private final Connection conn;
     private final String category;
     private final String subcategory;
     private final Integer simulationId;
     private final StanfordCoreNLP pipeline;
     private final Map<String, List<String>> templates;
-    private final Random random = new Random();
-    
-    // Question type weights according to AGENTS.md
-    private final Map<String, Double> questionTypeWeights = Map.of(
+    private Random random = new Random();
+
+    // Default weights according to AGENTS.md
+    private static final Map<String, Double> DEFAULT_QUESTION_TYPE_WEIGHTS = Map.of(
         "entailment", 0.4,
-        "widerspruch", 0.2, 
+        "widerspruch", 0.2,
         "nicht_erwaehnt", 0.15,
         "kernaussage", 0.15,
         "struktur", 0.1
     );
-    
-    // Difficulty distribution
-    private final Map<String, Double> difficultyWeights = Map.of(
+
+    private static final Map<String, Double> DEFAULT_DIFFICULTY_WEIGHTS = Map.of(
         "leicht", 0.3,
         "mittel", 0.5,
         "schwer", 0.2
     );
 
+    private Map<String, Double> questionTypeWeights = new HashMap<>(DEFAULT_QUESTION_TYPE_WEIGHTS);
+    private Map<String, Double> difficultyWeights = new HashMap<>(DEFAULT_DIFFICULTY_WEIGHTS);
+
+    private final List<QuestionRecord> generatedQuestions = new ArrayList<>();
+    private List<Proposition> lastPropositions = new ArrayList<>();
+    private final List<String> metaWarnings = new ArrayList<>();
+
     /**
      * Constructs the generator with DB connection and context.
      * Uses a lightweight approach that doesn't require Stanford CoreNLP models.
      */
     public TextverstaendnisGenerator(Connection conn, String category, String subcategory, Integer simulationId) {
         this.conn = conn;
         this.category = category;
         this.subcategory = subcategory;
         this.simulationId = simulationId;
 
         // Load question templates
         this.templates = loadTemplates();
 
         // Use a minimal pipeline that doesn't require external model files
         StanfordCoreNLP tempPipeline;
         try {
             Properties props = new Properties();
             props.setProperty("annotators", "tokenize,ssplit");
             props.setProperty("tokenize.language", "de"); // German tokenization
             props.setProperty("ssplit.newlineIsSentenceBreak", "always");
             tempPipeline = new StanfordCoreNLP(props);
             System.out.println("TextverstaendnisGenerator: Initialized with lightweight NLP pipeline");
         } catch (Exception e) {
             System.err.println("Warning: Could not initialize NLP pipeline, using fallback text processing: " + e.getMessage());
             tempPipeline = null;
         }
         this.pipeline = tempPipeline;
     }
 
     /**
      * Main execution method following AGENTS.md specifications.
      */
     public void execute(String passageText, int questionCount) throws SQLException {
+        execute(passageText, questionCount, null);
+    }
+
+    /**
+     * Execution method with parameter map for weight overrides.
+     */
+    public String execute(String passageText, int questionCount, Map<String, Object> params) throws SQLException {
+        generatedQuestions.clear();
+        lastPropositions = new ArrayList<>();
+        metaWarnings.clear();
+
+        applyParams(params);
+
+        if (params != null && params.get("anzahl_fragen_total") instanceof Number n) {
+            questionCount = n.intValue();
+        }
+
+        if (passageText.split("\\s+").length < 120) {
+            metaWarnings.add("Passage kürzer als 120 Wörter");
+            questionCount = Math.min(questionCount, 3);
+        }
+
         System.out.println("Generating " + questionCount + " questions using AGENTS.md methodology...");
-        
+
         // Comprehensive text analysis
         TextAnalysis analysis = analyzeText(passageText);
-        
+        lastPropositions = analysis.propositions;
+
         // Distribute questions across types and difficulties
         List<QuestionSpec> questionSpecs = distributeQuestions(questionCount);
-        
+
         // Generate questions systematically
         for (int i = 0; i < questionSpecs.size(); i++) {
             QuestionSpec spec = questionSpecs.get(i);
             try {
                 QuestionData questionData = generateQuestion(spec, analysis);
                 
                 // Insert into database
-                int questionId = insertQuestion(questionData.text, i + 1, getPassageId(passageText));
+                int passageId = getPassageId(passageText);
+                int questionId = insertQuestion(questionData.text, i + 1, passageId);
                 insertAnswerOptions(questionId, questionData.options, questionData.correctIndex);
-                
+
+                storeQuestionRecord("Q" + (i + 1), spec, questionData, analysis);
                 System.out.println("Generated " + spec.type + " question (" + spec.difficulty + ")");
-                
+
             } catch (Exception e) {
                 System.err.println("Failed to generate question of type " + spec.type + ": " + e.getMessage());
             }
         }
-        
+
         System.out.println("Question generation completed successfully!");
+        int passageId = getPassageId(passageText);
+        return toJson(passageId);
     }
 
     /**
      * Analyzes text using available NLP capabilities with fallback for missing models.
      */
     private TextAnalysis analyzeText(String text) {
         try {
             List<CoreMap> sentences = new ArrayList<>();
             List<RelationTriple> relations = new ArrayList<>();
             List<Proposition> propositions = new ArrayList<>();
             
             if (pipeline != null) {
                 // Use Stanford CoreNLP if available
                 Annotation document = new Annotation(text);
                 pipeline.annotate(document);
                 sentences = document.get(CoreAnnotations.SentencesAnnotation.class);
                 System.out.println("TextverstaendnisGenerator: Processed " + sentences.size() + " sentences with CoreNLP");
             } else {
                 // Fallback: simple sentence splitting
                 String[] sentenceArray = text.split("[.!?]+");
                 for (String sent : sentenceArray) {
                     if (sent.trim().length() > 0) {
                         // Create a simple CoreMap-like object
                         Annotation sentAnnotation = new Annotation(sent.trim());
                         sentences.add(sentAnnotation);
diff --git a/src/main/java/generator/TextverstaendnisGenerator.java b/src/main/java/generator/TextverstaendnisGenerator.java
index a9ea4260bd937dd38519f2d5a696ebd35f1a5292..c1b5924fa982ec4a7bd3c3f36bb9b2ed7f58dacc 100644
--- a/src/main/java/generator/TextverstaendnisGenerator.java
+++ b/src/main/java/generator/TextverstaendnisGenerator.java
@@ -325,52 +358,52 @@ public class TextverstaendnisGenerator {
                 return generateContradictionQuestion(stem, analysis, spec.difficulty);
             case "nicht_erwaehnt":
                 return generateNotMentionedQuestion(stem, analysis, spec.difficulty);
             case "kernaussage":
                 return generateCoreStatementQuestion(stem, analysis, spec.difficulty);
             case "struktur":
                 return generateStructureQuestion(stem, analysis, spec.difficulty);
             default:
                 return generateEntailmentQuestion(stem, analysis, spec.difficulty);
         }
     }
 
     /**
      * Generate entailment question (logical inference from text).
      */
     private QuestionData generateEntailmentQuestion(String stem, TextAnalysis analysis, String difficulty) {
         List<String> options = new ArrayList<>();
         
         // Correct option: valid inference from text
         String correctOption = createEntailmentOption(analysis);
         options.add(correctOption);
         
         // Generate 4 distractors using systematic transformations
         options.add(createNegationDistractor(correctOption));
         options.add(createQuantifierFlipDistractor(correctOption));
-        options.add(createEntitySwapDistractor(analysis));
-        options.add(createOutOfScopeDistractor(analysis));
+        options.add(createConditionDropDistractor(correctOption));
+        options.add(createTemporalFlipDistractor(correctOption));
         
         Collections.shuffle(options);
         int correctIndex = options.indexOf(correctOption);
         
         return new QuestionData(stem, options, correctIndex);
     }
 
     /**
      * Generate contradiction question.
      */
     private QuestionData generateContradictionQuestion(String stem, TextAnalysis analysis, String difficulty) {
         List<String> options = new ArrayList<>();
         
         // Select a statement that contradicts the text
         String correctOption = createContradictionOption(analysis);
         options.add(correctOption);
         
         // Generate 4 distractors (statements that are true or neutral)
         options.add(createTrueStatement(analysis));
         options.add(createNeutralStatement(analysis));
         options.add(createTrueStatement(analysis));
         options.add(createNeutralStatement(analysis));
         
         Collections.shuffle(options);
         int correctIndex = options.indexOf(correctOption);
diff --git a/src/main/java/generator/TextverstaendnisGenerator.java b/src/main/java/generator/TextverstaendnisGenerator.java
index a9ea4260bd937dd38519f2d5a696ebd35f1a5292..c1b5924fa982ec4a7bd3c3f36bb9b2ed7f58dacc 100644
--- a/src/main/java/generator/TextverstaendnisGenerator.java
+++ b/src/main/java/generator/TextverstaendnisGenerator.java
@@ -451,50 +484,63 @@ public class TextverstaendnisGenerator {
         }
         if (original.contains("kann")) {
             return original.replace("kann", "kann nicht");
         }
         return "Nicht: " + original;
     }
 
     private String createQuantifierFlipDistractor(String original) {
         return original.replace("manchmal", "immer")
                      .replace("selten", "häufig")
                      .replace("teilweise", "vollständig");
     }
 
     private String createEntitySwapDistractor(TextAnalysis analysis) {
         if (!analysis.propositions.isEmpty()) {
             Proposition prop = analysis.propositions.get(random.nextInt(analysis.propositions.size()));
             return prop.obj + " " + prop.pred + " " + prop.subj; // swap subject/object
         }
         return "Verwechselte Entitäten aus dem Text";
     }
 
     private String createOutOfScopeDistractor(TextAnalysis analysis) {
         return "Eine plausible, aber nicht im Text erwähnte Aussage";
     }
 
+    private String createConditionDropDistractor(String original) {
+        if (original.contains("wenn")) {
+            return original.replaceAll("nur\\s+wenn", "").replace("wenn", "").trim();
+        }
+        return original + " ohne Bedingung";
+    }
+
+    private String createTemporalFlipDistractor(String original) {
+        return original.replace("zunächst", "abschließend")
+                       .replace("erst", "zuletzt")
+                       .replace("später", "früher");
+    }
+
     private String createTrueStatement(TextAnalysis analysis) {
         if (!analysis.sentences.isEmpty()) {
             return paraphraseSentence(analysis.sentences.get(random.nextInt(analysis.sentences.size())).toString());
         }
         return "Eine wahre Aussage aus dem Text";
     }
 
     private String createNeutralStatement(TextAnalysis analysis) {
         return "Eine neutrale Aussage, die weder bestätigt noch widerlegt wird";
     }
 
     private String createContradictionOption(TextAnalysis analysis) {
         return "Eine Aussage, die dem Text widerspricht";
     }
 
     private String createNotMentionedOption(TextAnalysis analysis) {
         return "Eine plausible, aber nicht erwähnte Information";
     }
 
     private String createEntailmentOption(TextAnalysis analysis) {
         if (!analysis.propositions.isEmpty()) {
             Proposition prop = analysis.propositions.get(random.nextInt(analysis.propositions.size()));
             return "Daraus folgt: " + prop.subj + " " + prop.pred + " " + prop.obj;
         }
         return "Eine logische Schlussfolgerung aus dem Text";
diff --git a/src/main/java/generator/TextverstaendnisGenerator.java b/src/main/java/generator/TextverstaendnisGenerator.java
index a9ea4260bd937dd38519f2d5a696ebd35f1a5292..c1b5924fa982ec4a7bd3c3f36bb9b2ed7f58dacc 100644
--- a/src/main/java/generator/TextverstaendnisGenerator.java
+++ b/src/main/java/generator/TextverstaendnisGenerator.java
@@ -670,50 +716,163 @@ public class TextverstaendnisGenerator {
             stmt.setInt(6, passageId);
             stmt.executeUpdate();
             try (ResultSet rs = stmt.getGeneratedKeys()) {
                 if (rs.next()) {
                     return rs.getInt(1);
                 }
             }
         }
         throw new SQLException("Failed to insert question");
     }
 
     private void insertAnswerOptions(int questionId, List<String> options, int correctIndex) throws SQLException {
         String sql = "INSERT INTO options (question_id, label, text, is_correct) VALUES (?, ?, ?, ?)";
         try (PreparedStatement stmt = conn.prepareStatement(sql)) {
             for (int i = 0; i < options.size(); i++) {
                 stmt.setInt(1, questionId);
                 stmt.setString(2, String.valueOf((char)('A' + i))); // Generate labels A, B, C, D, E
                 stmt.setString(3, options.get(i));
                 stmt.setBoolean(4, i == correctIndex);
                 stmt.addBatch();
             }
             stmt.executeBatch();
         }
     }
 
+    // Parameter handling
+    private void applyParams(Map<String, Object> params) {
+        if (params == null) {
+            return;
+        }
+
+        if (params.get("frage_typen_gewichtung") instanceof Map<?, ?> map) {
+            Map<String, Double> newWeights = new HashMap<>();
+            for (Map.Entry<?, ?> e : map.entrySet()) {
+                if (e.getValue() instanceof Number n) {
+                    newWeights.put(e.getKey().toString(), n.doubleValue());
+                }
+            }
+            if (!newWeights.isEmpty()) {
+                questionTypeWeights = newWeights;
+            }
+        }
+
+        if (params.get("schwierigkeitsverteilung") instanceof Map<?, ?> map) {
+            Map<String, Double> newDiff = new HashMap<>();
+            for (Map.Entry<?, ?> e : map.entrySet()) {
+                if (e.getValue() instanceof Number n) {
+                    newDiff.put(e.getKey().toString(), n.doubleValue());
+                }
+            }
+            if (!newDiff.isEmpty()) {
+                difficultyWeights = newDiff;
+            }
+        }
+
+        if (params.get("seed") instanceof Number n) {
+            random = new Random(n.longValue());
+        }
+    }
+
+    private void storeQuestionRecord(String frageId, QuestionSpec spec, QuestionData data, TextAnalysis analysis) {
+        List<Option> optionList = new ArrayList<>();
+        Map<String, List<String>> trans = new LinkedHashMap<>();
+        for (int i = 0; i < data.options.size(); i++) {
+            String label = String.valueOf((char)('A' + i));
+            optionList.add(new Option(label, data.options.get(i)));
+            if (i != data.correctIndex) {
+                // Simple heuristic: mark by order of transformation methods used
+                List<String> t = new ArrayList<>();
+                switch (i) {
+                    case 0 -> t.add("negation");
+                    case 1 -> t.add("quantifier_flip");
+                    case 2 -> t.add("condition_drop");
+                    case 3 -> t.add("temporal_flip");
+                }
+                trans.put(label, t);
+            }
+        }
+
+        String korrektLabel = String.valueOf((char)('A' + data.correctIndex));
+        List<String> evidence = analysis.propositions.isEmpty() ? new ArrayList<>() : List.of(analysis.propositions.get(0).id);
+
+        generatedQuestions.add(new QuestionRecord(frageId, spec.type, spec.difficulty,
+                data.text, optionList, korrektLabel, evidence, trans));
+    }
+
+    public String toJson(int passageId) {
+        Map<String, Object> root = new LinkedHashMap<>();
+        root.put("text_id", String.valueOf(passageId));
+
+        List<Map<String, Object>> qList = new ArrayList<>();
+        for (QuestionRecord q : generatedQuestions) {
+            Map<String, Object> qMap = new LinkedHashMap<>();
+            qMap.put("frage_id", q.frageId);
+            qMap.put("typ", q.typ);
+            qMap.put("schwierigkeitsgrad", q.schwierigkeitsgrad);
+            qMap.put("stem", q.stem);
+
+            List<Map<String, String>> opts = new ArrayList<>();
+            for (Option o : q.optionen) {
+                Map<String, String> om = new LinkedHashMap<>();
+                om.put("label", o.label);
+                om.put("text", o.text);
+                opts.add(om);
+            }
+            qMap.put("optionen", opts);
+            qMap.put("korrekt", q.korrekt);
+            qMap.put("evidence_props", q.evidenceProps);
+            qMap.put("transformations_distraktoren", q.transformationsDistraktoren);
+
+            qList.add(qMap);
+        }
+        root.put("fragen", qList);
+
+        List<Map<String, Object>> propList = new ArrayList<>();
+        for (Proposition p : lastPropositions) {
+            Map<String, Object> pm = new LinkedHashMap<>();
+            pm.put("id", p.id);
+            pm.put("subj", p.subj);
+            pm.put("pred", p.pred);
+            pm.put("obj", p.obj);
+            pm.put("mods", p.modifiers);
+            propList.add(pm);
+        }
+        root.put("propositionen", propList);
+
+        if (!metaWarnings.isEmpty()) {
+            root.put("meta_warnungen", metaWarnings);
+        }
+
+        try {
+            ObjectMapper mapper = new ObjectMapper();
+            return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
+        } catch (Exception e) {
+            return "{}";
+        }
+    }
+
     // Helper classes
     
     private static class QuestionSpec {
         String type;
         String difficulty;
         
         QuestionSpec(String type, String difficulty) {
             this.type = type;
             this.difficulty = difficulty;
         }
     }
     
     private static class TextAnalysis {
         List<CoreMap> sentences;
         List<RelationTriple> relations;
         List<Proposition> propositions;
         Annotation document;
         
         TextAnalysis(List<CoreMap> sentences, List<RelationTriple> relations, 
                     List<Proposition> propositions, Annotation document) {
             this.sentences = sentences;
             this.relations = relations;
             this.propositions = propositions;
             this.document = document;
         }
diff --git a/src/main/java/generator/TextverstaendnisGenerator.java b/src/main/java/generator/TextverstaendnisGenerator.java
index a9ea4260bd937dd38519f2d5a696ebd35f1a5292..c1b5924fa982ec4a7bd3c3f36bb9b2ed7f58dacc 100644
--- a/src/main/java/generator/TextverstaendnisGenerator.java
+++ b/src/main/java/generator/TextverstaendnisGenerator.java
@@ -729,26 +888,61 @@ public class TextverstaendnisGenerator {
         Proposition(String id, String subj, String pred, String obj, List<String> modifiers) {
             this.id = id;
             this.subj = subj;
             this.pred = pred;
             this.obj = obj;
             this.modifiers = modifiers;
         }
         
         @Override
         public String toString() {
             return subj + " " + pred + " " + obj;
         }
     }
 
     private static class QuestionData {
         String text;
         List<String> options;
         int correctIndex;
         
         QuestionData(String text, List<String> options, int correctIndex) {
             this.text = text;
             this.options = new ArrayList<>(options);
             this.correctIndex = correctIndex;
         }
     }
+
+    private static class Option {
+        String label;
+        String text;
+
+        Option(String label, String text) {
+            this.label = label;
+            this.text = text;
+        }
+    }
+
+    private static class QuestionRecord {
+        String frageId;
+        String typ;
+        String schwierigkeitsgrad;
+        String stem;
+        List<Option> optionen;
+        String korrekt;
+        List<String> evidenceProps;
+        Map<String, List<String>> transformationsDistraktoren;
+
+        QuestionRecord(String frageId, String typ, String schwierigkeitsgrad,
+                       String stem, List<Option> optionen, String korrekt,
+                       List<String> evidenceProps,
+                       Map<String, List<String>> transformationsDistraktoren) {
+            this.frageId = frageId;
+            this.typ = typ;
+            this.schwierigkeitsgrad = schwierigkeitsgrad;
+            this.stem = stem;
+            this.optionen = optionen;
+            this.korrekt = korrekt;
+            this.evidenceProps = evidenceProps;
+            this.transformationsDistraktoren = transformationsDistraktoren;
+        }
+    }
 }
 
EOF
)