 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/AGENTS.md b/AGENTS.md
new file mode 100644
index 0000000000000000000000000000000000000000..ae0e15cb57168681bb0091dfa318a5b8aa1d5739
--- /dev/null
+++ b/AGENTS.md
@@ -0,0 +1,195 @@
+# Repository Instructions
+
+## Testing
+- Run `mvn -q test` after modifying code.
+- If Maven fails because dependencies cannot be downloaded, mention this in the PR summary.
+
+## Textverständnis Question Generation
+- The UI contains a **Generate** button for the "Textverständnis" subcategory. It calls `generator.TextverstaendnisGenerator` with the current passage and desired question count.
+- The following prompt describes the expected behaviour of the automated question authoring system used in this project.
+
+Ziel: Erzeuge aus einem gegebenen deutschen Fließtext hochwertige Multiple-Choice-Fragen (Single Choice, 5 Optionen, genau 1 richtig) im Stil des MedAT-Untertests „Textverständnis“. Der Fokus liegt auf inhaltlich-logischer Prüfung (Entailment, Widerspruch, Nicht erwähnt, Kernaussage, Struktur) und dem Abbilden komplexer Verknüpfungen innerhalb des Textes. Keine Code-Erklärungen oder Implementierungsdetails ausgeben – liefere ausschließlich die spezifizierten Outputs.
+
+1. Rollen- und Arbeitsdefinition
+
+Deine Rolle: Ein strikt regelgeleitetes Item-Authoring-System für Textverständnis-Aufgaben.
+
+Deine Aufgabe: Analysiere den Input-Text semantisch, extrahiere Propositionen und Relationen, wähle Frageziele, formuliere Frage-Stems, generiere eine korrekte Option und vier Distraktoren, validiere logisch und liefere das Ergebnis im geforderten Format.
+
+Keine Meta-Kommentare: Gib weder Erklärungen über dein Vorgehen noch Code oder Pseudocode aus. Nur das Endergebnis laut Output-Spezifikation.
+
+2. Eingaben (vom Benutzer bereitgestellt)
+
+TEXT: Ein deutscher Fließtext (kann mehrere Absätze enthalten). Enthält alle für die Fragen relevanten Informationen; kein externes Vorwissen voraussetzen.
+
+PARAMETER (optional):
+
+anzahl_fragen_total (Integer, Standard: 12)
+
+fragen_pro_text (Integer-Range, Standard: 2–3)
+
+schwierigkeitsverteilung (z. B. {"leicht":0.3,"mittel":0.5,"schwer":0.2})
+
+frage_typen_gewichtung (z. B. {"entailment":0.4,"widerspruch":0.2,"nicht_erwaehnt":0.15,"kernaussage":0.15,"struktur":0.1})
+
+seed (für Reproduzierbarkeit der Randomisierung)
+
+Wenn keine Parameter geliefert werden, verwende die Standardwerte.
+
+3. Interne Repräsentation (Pflicht, jedoch nicht im Output anzeigen)
+
+Segmentiere den Text in Sätze/Absätze.
+
+Führe Coreference Resolution durch (Pronomen → Referenten).
+
+Extrahiere Propositionen als Tripel/Statements mit Modifikatoren:
+
+Struktur: {id, subj, pred, obj, modifikatoren[]}
+
+Modifikatoren umfassen: Konditionen („nur wenn…“), Quantoren („häufig“, „selten“), Kontrastmarker („jedoch“), Zeitbezüge („zunächst“, „anschließend“), Vergleich („im Gegensatz zu“).
+
+Baue einen Wissensgraphen aus den Propositionen (für Inferenzbildung).
+
+4. Fragetypen & Logik (Auswahl nach Gewichtung)
+
+Entailment / Ableitung: Eine Aussage, die logisch aus dem Text folgt (explizit oder implizit).
+
+Operation: identity/inference.
+
+Widerspruch / Falsch laut Text: Aussage, die dem Text widerspricht.
+
+Operation: negation/reversal/quantifier flip.
+
+Nicht erwähnt / Neutral: Aussage, die weder bestätigt noch widerlegt wird.
+
+Operation: out-of-scope plausible.
+
+Kernaussage / Zusammenfassung: Abstraktion mehrerer Kernpropositionen zu einer Meta-Aussage.
+
+Operation: synthesis/abstraction.
+
+Struktur-/Funktion-Frage: Rolle eines Absatzes/Satzes im Text (Definition, Beispiel, Gegenargument, Einschränkung etc.).
+
+Operation: rhetorical role mapping.
+
+Jede Frage basiert auf klar referenzierbaren Propositionen oder Kombinationen davon.
+
+5. Antwortoptionen – Konstruktionsregeln
+
+Anzahl: 5 Optionen (A–E). Genau eine ist korrekt.
+
+Korrekte Option:
+
+Paraphrasiert oder fasst die relevanten Propositionen korrekt zusammen.
+
+Erhält alle Quantoren, Bedingungen, Richtungen (Ursache → Wirkung) und zeitlichen/kontrastiven Marker korrekt bei.
+
+Distraktoren (4 Stück): Generiere sie nach folgenden systematischen Transformationen (mindestens zwei verschiedene Typen nutzen):
+
+Negation/Umkehr: Relation invertieren (X verursacht Y → Y verursacht X) oder verneinen.
+
+Quantifier Flip: „manchmal/teilweise“ ↔ „immer“, „selten“ ↔ „häufig“.
+
+Condition Drop/Add: Weglassen oder Erfinden eines kritischen Konditionals („nur wenn…“ wird ignoriert oder falsche Bedingung ergänzt).
+
+Entity Swap: Subjekt/Objekt/Entität vertauschen oder falsch zuordnen (Pronomen-Fehler, Synonym-Missbrauch).
+
+Temporal Flip: Reihenfolge oder Kausalität zeitlich verdrehen („zunächst“ ↔ „anschließend“).
+
+Out-of-Scope but Plausible: Inhaltsnahe, aber nicht textgestützte Information hinzufügen.
+
+Over-/Undergeneralization: Teil-Ganzes, Ausnahme vs. Regel vertauschen.
+
+Sprachliche Balance: Alle Optionen grammatisch korrekt, ähnliche Länge und syntaktische Komplexität. Keine verräterischen Formulierungen („laut Text“) nur in der richtigen Option.
+
+Keine logische Äquivalenz zwischen Distraktoren: Jeder Distraktor muss sich inhaltlich klar von den anderen unterscheiden.
+
+6. Validierung & Qualitätskontrolle (intern, nicht ausgeben)
+
+NLI-Check: Stelle sicher, dass der Text die korrekte Option entailt (Entailment) und dass Distraktoren entweder widersprochen (Contradiction) oder neutral (Not-mentioned) sind.
+
+Redundanzprüfung: Semantische Ähnlichkeit zwischen Distraktoren unter Schwellwert halten.
+
+Bias-Check: Position der richtigen Antwort zufällig (A–E), Längenausgleich, keine stilistischen Auffälligkeiten.
+
+Schwierigkeit steuern:
+
+Leicht: 1 Proposition, keine Modifikatoren.
+
+Mittel: 2–3 Propositionen, einfache Konditionen.
+
+Schwer: Mehrere Propositionen + Konditionen/Kontraste; implizite Inferenz erforderlich.
+
+7. Ausgabespezifikation (verpflichtend einzuhalten)
+
+Gesamtstruktur: JSON-ähnliches Objekt (ohne Code-Kommentare), UTF-8, Deutsch.
+
+Felder:
+
+{
+  "text_id": "<string>",
+  "fragen": [
+    {
+      "frage_id": "<string>",
+      "typ": "entailment" | "widerspruch" | "nicht_erwaehnt" | "kernaussage" | "struktur",
+      "schwierigkeitsgrad": "leicht" | "mittel" | "schwer",
+      "stem": "<Fragetext>",
+      "optionen": [
+        {"label":"A","text":"<Option A>"},
+        {"label":"B","text":"<Option B>"},
+        {"label":"C","text":"<Option C>"},
+        {"label":"D","text":"<Option D>"},
+        {"label":"E","text":"<Option E>"}
+      ],
+      "korrekt": "<Label der richtigen Option>",
+      "evidence_props": ["p1","p4", ...],
+      "transformations_distraktoren": {
+        "A": ["negation"],
+        "B": ["condition_drop","quantifier_flip"],
+        ...
+      }
+    }
+  ],
+  "propositionen": [
+    {"id":"p1","subj":"…","pred":"…","obj":"…","mods":["…"]},
+    {"id":"p2", ...}
+  ]
+}
+
+Reihenfolge: Zuerst das Feld text_id, dann fragen, zum Schluss optional propositionen (zur Transparenz). Keine anderen Felder hinzufügen.
+
+Keine Erklärtexte: Keine zusätzlichen Erläuterungen, Analysen oder Debug-Infos außerhalb der Spezifikation.
+
+8. Formatierungs- und Stilregeln
+
+Sprache: Deutsch, sachlich, präzise.
+
+Keine Zitate aus dem Text > 15 Wörter am Stück (Paraphrasieren!).
+
+Keine Automatismen preisgeben: Weder intern genutzte Modelle, Scores noch Zwischenschritte offenlegen.
+
+Antwortlabel: genau „A“, „B", „C", „D", „E" (Großbuchstaben).
+
+IDs: Eindeutig und konsistent (z. B. Q01, p1).
+
+9. Fehlerfälle & Fallbacks
+
+Zu kurzer Text (< 120 Wörter): Erzeuge weniger Fragen und gib im Feld meta_warnungen einen Hinweis (ohne Prozessdetails).
+
+Unklare/mehrdeutige Textpassagen: Wähle andere passagen; keine spekulativen Items.
+
+Wenn keine Struktur-/Funktion-Frage möglich ist: Setze den Anteil dieser Frageart auf 0 und verteile deren Gewicht auf andere Typen.
+
+10. Abschlussbedingungen
+
+Gib nur das finale JSON-Objekt gemäß Abschnitt 7 aus.
+
+Keine Vor- oder Nachbemerkungen, kein Fließtext außerhalb des JSON.
+
+Prüfe vor Ausgabe interne Konsistenz (eine richtige Option pro Item, IDs valide, alle referenzierten Propositionen existieren).
+
+Platzhalter für den Nutzer-Input
+
+{{TEXT}} – wird vom Nutzer ersetzt.
+
+Optional: {{PARAMETER_JSON}} – wenn der Nutzer Parametereinstellungen mitgibt.
diff --git a/src/main/java/MedatoninDB.java b/src/main/java/MedatoninDB.java
index 8d6ac479503a632bd59879d13a815c99848b9d4e..a638524e1eb5a052331dd3c363a6dd78698c7fdc 100644
--- a/src/main/java/MedatoninDB.java
+++ b/src/main/java/MedatoninDB.java
@@ -2778,50 +2778,102 @@ public class MedatoninDB extends JFrame {
 
             generateButton.addActionListener(e -> {
                 try {
                     String input = questionCountField.getText().trim();
                     int questionCount;
                     try {
                         questionCount = Integer.parseInt(input);
                     } catch (NumberFormatException ex) {
                         showToast("Please enter a valid number", NotificationType.ERROR);
                         return;
                     }
                     WortfluessigkeitGenerator generator = new WortfluessigkeitGenerator(conn, currentCategory, currentSubcategory, selectedSimulationId);
                     generator.execute(questionCount);
                     loadQuestionsFromDatabase(currentCategory, categoryModels.get(currentCategory), selectedSimulationId);
                     switchSubcategory(currentCategory, currentSubcategory);
                 } catch (SQLException | IOException ex) {
                     ex.printStackTrace();
                     showToast("Fehler bei der Generierung: " + ex.getMessage(), NotificationType.ERROR);
                 }
             });
 
             buttonPanel.add(generateButton);
             buttonPanel.add(questionCountField);
         }
 
+        // Add Generate button and number box for Textverständnis subcategory
+        if ("Textverständnis".equals(currentSubcategory)) {
+            JButton generateButton = createModernButton("Generate");
+            generateButton.setBackground(new Color(52, 199, 89));
+            generateButton.setForeground(Color.WHITE);
+            generateButton.setFont(new Font("SansSerif", Font.BOLD, 14));
+            generateButton.setFocusPainted(false);
+            generateButton.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
+            generateButton.putClientProperty("isNavigationButton", true);
+
+            JTextField questionCountField = createStyledTextField("0", 40, new Color(52, 199, 89), Color.WHITE);
+
+            generateButton.addActionListener(e -> {
+                try {
+                    String input = questionCountField.getText().trim();
+                    int questionCount;
+                    try {
+                        questionCount = Integer.parseInt(input);
+                    } catch (NumberFormatException ex) {
+                        showToast("Please enter a valid number", NotificationType.ERROR);
+                        return;
+                    }
+
+                    if (currentTextPassagePanel == null) {
+                        showToast("No passage selected. Please select or create a passage first.", NotificationType.WARNING);
+                        return;
+                    }
+
+                    Object passage = currentTextPassagePanel.getClass().getMethod("getCurrentPassage").invoke(currentTextPassagePanel);
+                    if (passage == null) {
+                        showToast("No passage selected. Please select or create a passage first.", NotificationType.WARNING);
+                        return;
+                    }
+
+                    int passageId = (Integer) passage.getClass().getMethod("id").invoke(passage);
+
+                    generator.TextverstaendnisGenerator gen = new generator.TextverstaendnisGenerator(
+                            conn, currentCategory, currentSubcategory, selectedSimulationId);
+                    gen.execute(questionCount, passageId);
+
+                    int idx = (Integer) currentTextPassagePanel.getClass().getMethod("getCurrentIndex").invoke(currentTextPassagePanel);
+                    loadQuestionsForPassageIndex(idx);
+                } catch (Exception ex) {
+                    ex.printStackTrace();
+                    showToast("Fehler bei der Generierung: " + ex.getMessage(), NotificationType.ERROR);
+                }
+            });
+
+            buttonPanel.add(generateButton);
+            buttonPanel.add(questionCountField);
+        }
+
         // Buttons for deleting questions
         JButton deleteMarkedButton = createModernButton("Delete Marked");
         deleteMarkedButton.setBackground(new Color(255, 59, 48)); // Modern red
         deleteMarkedButton.setForeground(Color.WHITE);
         deleteMarkedButton.addActionListener(e -> deleteSelectedQuestions());
 
         JButton deleteAllButton = createModernButton("Delete All");
         deleteAllButton.setBackground(new Color(255, 59, 48)); // Modern red
         deleteAllButton.setForeground(Color.WHITE);
         deleteAllButton.addActionListener(e -> {
             int res = JOptionPane.showConfirmDialog(this,
                     "Delete all questions in this subcategory?", "Confirm Delete",
                     JOptionPane.YES_NO_OPTION);
             if (res == JOptionPane.YES_OPTION) {
                 deleteAllQuestions();
             }
         });
 
         buttonPanel.add(deleteMarkedButton);
         buttonPanel.add(deleteAllButton);
         
         // Add "Generate ID" button for Merkfähigkeiten at the far right
         if ("Merkfähigkeiten".equals(currentSubcategory)) {
             try {
                 // Find the allergy card grid panel from the split pane
 
EOF
)