 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -77,51 +77,52 @@ public class Docx4jPrinter {
             java.util.List<String> order,
             java.util.List<java.util.List<Object>> introPages) throws Docx4JException {
         WordprocessingMLPackage pkg = WordprocessingMLPackage.createPackage();
         int pageIndex = 0;
         for (String subcat : order) {
             if (pageIndex < introPages.size()) {
                 for (Object o : introPages.get(pageIndex)) {
                     pkg.getMainDocumentPart().addObject(o);
                 }
                 pageIndex++;
             }
             DefaultTableModel model = subcats.get(subcat);
             if (model != null) {
                 addQuestions(pkg, model);
             }
             addPageBreak(pkg);
         }
         return pkg;
     }
 
     /**
      * Append the given question table to the document with proper handling for
      * different question types.
      */
     public void addQuestions(WordprocessingMLPackage pkg, DefaultTableModel model) {
-        int figurenQuestionCount = 0; // Track Figuren questions for pagination
+        int figurenQuestionCount = 0; // Track total Figuren questions
+        int figurenBlocksOnPage = 0;  // Track Figuren question blocks on the current page
         
         for (int r = 0; r < model.getRowCount(); r++) {
             String number = Objects.toString(model.getValueAt(r, 0), "");
             Object questionObj = model.getValueAt(r, 1);
 
             if (!number.isEmpty() && questionObj != null) {
                 String questionText;
                 boolean isFigurenQuestion = false;
 
                 // Handle Figuren questions (DissectedPieces objects)
                 if (questionObj.getClass().getSimpleName().equals("DissectedPieces")) {
                     questionText = "Welche Figur lässt sich aus den folgenden Bausteinen zusammensetzen?";
                     isFigurenQuestion = true;
                     figurenQuestionCount++;
                 } else {
                     questionText = questionObj.toString();
                 }
 
                 // Add question text with special formatting for Figuren questions
                 P questionP = factory.createP();
                 
                 // For Figuren questions, add special spacing: Vor 6pt, Nach 6pt, Zeilenabstand Mehrfach 1.15
                 if (isFigurenQuestion) {
                     PPr questionPPr = factory.createPPr();
                     PPrBase.Spacing questionSpacing = factory.createPPrBaseSpacing();
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -137,70 +138,73 @@ public class Docx4jPrinter {
                 Text questionT = factory.createText();
                 questionT.setValue(number + ". " + questionText);
                 questionR.getContent().add(questionT);
                 questionP.getContent().add(questionR);
                 pkg.getMainDocumentPart().addObject(questionP);
 
                 // For Figuren questions, add the dissected pieces image
                 if (isFigurenQuestion) {
                     try {
                         addFigurenShapeImage(pkg, questionObj);
                     } catch (Exception e) {
                         // If image generation fails, add a text representation
                         P pieceP = factory.createP();
                         R pieceR = factory.createR();
                         Text pieceT = factory.createText();
                         pieceT.setValue("Bausteine: " + questionObj.toString());
                         pieceR.getContent().add(pieceT);
                         pieceP.getContent().add(pieceR);
                         pkg.getMainDocumentPart().addObject(pieceP);
                     }
                 }
 
                 // Add options/answers if they exist in the model
                 addQuestionOptions(pkg, model, r);
 
-                // For Figuren questions: no spacing between question blocks, 
-                // but add page break after every 3rd question
+                // For Figuren questions: no spacing between question blocks.
+                // After three blocks, start a new page and reset the counter.
                 if (isFigurenQuestion) {
-                    if (figurenQuestionCount % 3 == 0) {
+                    figurenBlocksOnPage++;
+                    if (figurenBlocksOnPage == 3) {
                         addPageBreak(pkg);
+                        figurenBlocksOnPage = 0;
                     }
                 } else {
                     // Add spacing after non-Figuren questions
                     addSpacing(pkg);
                 }
             }
         }
     }
 
     /**
      * Add questions with solutions to the document with proper handling for
      * different question types.
      */
     public void addQuestionsSolution(WordprocessingMLPackage pkg, DefaultTableModel model) {
-        int figurenQuestionCount = 0; // Track Figuren questions for pagination
+        int figurenQuestionCount = 0; // Track total Figuren questions
+        int figurenBlocksOnPage = 0;  // Track Figuren question blocks on the current page
         
         for (int r = 0; r < model.getRowCount(); r++) {
             String number = Objects.toString(model.getValueAt(r, 0), "");
             Object questionObj = model.getValueAt(r, 1);
             String solution = Objects.toString(model.getValueAt(r, 2), "");
 
             if (!number.isEmpty() && questionObj != null) {
                 String questionText;
                 boolean isFigurenQuestion = false;
 
                 // Handle Figuren questions (DissectedPieces objects)
                 if (questionObj.getClass().getSimpleName().equals("DissectedPieces")) {
                     questionText = "Welche Figur lässt sich aus den folgenden Bausteinen zusammensetzen?";
                     isFigurenQuestion = true;
                     figurenQuestionCount++;
                 } else {
                     questionText = questionObj.toString();
                 }
 
                 // Add question with special formatting for Figuren questions
                 P questionP = factory.createP();
                 
                 // For Figuren questions, add special spacing: Vor 6pt, Nach 6pt, Zeilenabstand Mehrfach 1.15
                 if (isFigurenQuestion) {
                     PPr questionPPr = factory.createPPr();
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -228,55 +232,57 @@ public class Docx4jPrinter {
                         // If image generation fails, add a text representation
                         P pieceP = factory.createP();
                         R pieceR = factory.createR();
                         Text pieceT = factory.createText();
                         pieceT.setValue("Bausteine: " + questionObj.toString());
                         pieceR.getContent().add(pieceT);
                         pieceP.getContent().add(pieceR);
                         pkg.getMainDocumentPart().addObject(pieceP);
                     }
                 }
 
                 // Add options/answers if they exist in the model
                 addQuestionOptions(pkg, model, r);
 
                 // Add solution if available
                 if (!solution.isEmpty()) {
                     P solutionP = factory.createP();
                     R solutionR = factory.createR();
                     Text solutionT = factory.createText();
                     solutionT.setValue("Lösung: " + solution);
                     solutionR.getContent().add(solutionT);
                     solutionP.getContent().add(solutionR);
                     pkg.getMainDocumentPart().addObject(solutionP);
                 }
 
-                // For Figuren questions: no spacing between question blocks, 
-                // but add page break after every 3rd question
+                // For Figuren questions: no spacing between question blocks.
+                // After three blocks, start a new page and reset the counter.
                 if (isFigurenQuestion) {
-                    if (figurenQuestionCount % 3 == 0) {
+                    figurenBlocksOnPage++;
+                    if (figurenBlocksOnPage == 3) {
                         addPageBreak(pkg);
+                        figurenBlocksOnPage = 0;
                     }
                 } else {
                     // Add spacing after non-Figuren questions
                     addSpacing(pkg);
                 }
             }
         }
     }
 
     /**
      * Add a stop sign page to the document with centered image or text.
      */
     public void addStopSignPage(WordprocessingMLPackage pkg) {
         // Create a new page
         addPageBreak(pkg);
 
         // Add multiple empty paragraphs for vertical centering
         for (int i = 0; i < 8; i++) {
             P emptyP = factory.createP();
             pkg.getMainDocumentPart().addObject(emptyP);
         }
 
         // Create centered paragraph for stop sign
         P centerP = factory.createP();
         PPr pPr = factory.createPPr();
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -346,57 +352,71 @@ public class Docx4jPrinter {
     }
 
     /**
      * Add spacing between questions.
      */
     private void addSpacing(WordprocessingMLPackage pkg) {
         P spacingP = factory.createP();
         pkg.getMainDocumentPart().addObject(spacingP);
     }
 
     /**
      * Add Figuren shape image to the document using reflection to avoid
      * compile-time dependencies.
      */
     private void addFigurenShapeImage(WordprocessingMLPackage pkg, Object dissectedPieces) throws Exception {
         try {
             // Use reflection to access the rotatedPieces field
             java.lang.reflect.Field rotatedPiecesField = dissectedPieces.getClass().getField("rotatedPieces");
             @SuppressWarnings("unchecked")
             java.util.List<Geometry> shapes = (java.util.List<Geometry>) rotatedPiecesField.get(dissectedPieces);
 
             if (shapes != null && !shapes.isEmpty()) {
                 // Generate image from shapes
                 BufferedImage shapeImage = createShapeImage(shapes);
 
+                // Scale to a maximum height of 4cm (~151px at 96dpi)
+                int width = shapeImage.getWidth();
+                int height = shapeImage.getHeight();
+                final int MAX_HEIGHT_PX = (int) (4 / 2.54 * 96);
+                if (height > MAX_HEIGHT_PX) {
+                    double scale = MAX_HEIGHT_PX / (double) height;
+                    width = (int) Math.round(width * scale);
+                    height = MAX_HEIGHT_PX;
+                }
+
                 // Convert to byte array
                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 ImageIO.write(shapeImage, "PNG", baos);
                 byte[] imageBytes = baos.toByteArray();
 
-                // Add image to document
-                addImageToDocument(pkg, imageBytes, "Figuren_Pieces.png");
+                // Add image to document with explicit size
+                P imgP = factory.createP();
+                R imgR = factory.createR();
+                addImageToRunWithSize(pkg, imgR, imageBytes, "Figuren_Pieces.png", width, height);
+                imgP.getContent().add(imgR);
+                pkg.getMainDocumentPart().addObject(imgP);
             }
         } catch (Exception e) {
             System.out.println("Could not generate Figuren image: " + e.getMessage());
             // Add fallback text
             P fallbackP = factory.createP();
             R fallbackR = factory.createR();
             Text fallbackT = factory.createText();
             fallbackT.setValue("Bausteine: " + dissectedPieces.toString());
             fallbackR.getContent().add(fallbackT);
             fallbackP.getContent().add(fallbackR);
             pkg.getMainDocumentPart().addObject(fallbackP);
         }
     }
 
     /**
      * Create a BufferedImage from geometry shapes with grey background, hand-drawn appearance, and optimally cropped height.
      */
     private BufferedImage createShapeImage(java.util.List<Geometry> shapes) {
         // Calculate bounding box
         Envelope totalBounds = new Envelope();
         for (Geometry shape : shapes) {
             totalBounds.expandToInclude(shape.getEnvelopeInternal());
         }
 
         // Create initial large image for drawing
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -463,57 +483,54 @@ public class Docx4jPrinter {
                 double offsetY = (random.nextDouble() - 0.5) * 2.0;
                 transform.translate(offsetX, offsetY);
 
                 // Draw the shape with grey fill and black outline
                 Shape awtShape = shapeWriter.toShape(shape);
                 Shape transformedShape = transform.createTransformedShape(awtShape);
                 
                 // Track the actual bounds of the drawn shape for cropping
                 java.awt.Rectangle shapeBounds2D = transformedShape.getBounds();
                 minY = Math.min(minY, shapeBounds2D.y);
                 maxY = Math.max(maxY, shapeBounds2D.y + shapeBounds2D.height);
                 
                 g2d.setColor(new java.awt.Color(180, 180, 180)); // Grey fill for shapes
                 g2d.fill(transformedShape);
                 g2d.setColor(java.awt.Color.BLACK);
                 g2d.draw(transformedShape);
 
                 currentX += shapeSpacing;
             } catch (Exception e) {
                 System.out.println("Error drawing shape: " + e.getMessage());
             }
         }
 
         g2d.dispose();
         
-        // Crop the image to remove excess white space above and below shapes
-        int padding = 10; // Small padding to avoid cutting off stroke edges
+        // Crop the image to the exact vertical bounds of the drawn shapes
+        int padding = 2; // minimal padding to avoid cutting off stroke edges
         int cropY = Math.max(0, minY - padding);
-        int cropHeight = Math.min(initialHeight - cropY, maxY + padding - cropY);
-        
-        // Ensure minimum height for readability
-        cropHeight = Math.max(cropHeight, 60);
+        int cropHeight = Math.min(initialHeight - cropY, (maxY + padding) - cropY);
         
         BufferedImage croppedImage = new BufferedImage(initialWidth, cropHeight, BufferedImage.TYPE_INT_RGB);
         Graphics2D cropG2d = croppedImage.createGraphics();
         cropG2d.drawImage(tempImage, 0, 0, initialWidth, cropHeight, 0, cropY, initialWidth, cropY + cropHeight, null);
         cropG2d.dispose();
         
         return croppedImage;
     }
 
     /**
      * Create an image for a single option shape using grey fill and black outline - optimized for table cells.
      */
     private BufferedImage createOptionShapeImage(String wkt) throws Exception {
         Geometry geometry = new WKTReader().read(wkt);
 
         // Smaller dimensions to fit properly in table cells
         int width = 120;  // Reduced from 300
         int height = 100; // Reduced from 240
         BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
         Graphics2D g2d = image.createGraphics();
         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
         g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
 
         g2d.setColor(Color.WHITE);
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -565,50 +582,56 @@ public class Docx4jPrinter {
             
             // Center the table
             Jc tblJc = factory.createJc();
             tblJc.setVal(JcEnumeration.CENTER);
             tblPr.setJc(tblJc);
             
             table.setTblPr(tblPr);
             
             Tr imageRow = factory.createTr();
             Tr labelRow = factory.createTr();
 
             for (Object opt : options) {
                 String label = String.valueOf(opt.getClass().getMethod("getLabel").invoke(opt));
                 String text = String.valueOf(opt.getClass().getMethod("getText").invoke(opt));
                 String shapeData = (String) opt.getClass().getMethod("getShapeData").invoke(opt);
 
                 // Image cell with proper sizing
                 Tc imgCell = factory.createTc();
                 
                 // Set cell width to accommodate smaller images
                 TcPr imgCellPr = factory.createTcPr();
                 TblWidth imgCellWidth = factory.createTblWidth();
                 imgCellWidth.setType("dxa");
                 imgCellWidth.setW(BigInteger.valueOf(1800)); // Reduced width for smaller images
                 imgCellPr.setTcW(imgCellWidth);
+
+                // Center content vertically
+                TcPrInner.VAlign vAlign = factory.createTcPrInnerVAlign();
+                vAlign.setVal(STVerticalJc.CENTER);
+                imgCellPr.setVAlign(vAlign);
+
                 imgCell.setTcPr(imgCellPr);
                 
                 P imgP = factory.createP();
                 PPr imgPPr = factory.createPPr();
                 
                 // Center alignment
                 Jc jc = factory.createJc();
                 jc.setVal(JcEnumeration.CENTER);
                 imgPPr.setJc(jc);
                 
                 // Spacing: Vor 0pt, Nach 3pt, Einfach
                 PPrBase.Spacing imgSpacing = factory.createPPrBaseSpacing();
                 imgSpacing.setBefore(BigInteger.valueOf(0));   // 0pt
                 imgSpacing.setAfter(BigInteger.valueOf(60));   // 3pt = 60 twips
                 imgSpacing.setLine(BigInteger.valueOf(240));   // Single line spacing = 240 twips
                 imgSpacing.setLineRule(STLineSpacingRule.AUTO);
                 imgPPr.setSpacing(imgSpacing);
                 
                 imgP.setPPr(imgPPr);
 
                 if ("X".equals(text) || "E".equalsIgnoreCase(label)) {
                     R r = factory.createR();
                     
                     // Make X bold and 20pt
                     RPr rPr = factory.createRPr();
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index cd2b9d166bf2efc3f19f8e4a18528f15f35d141c..d5b290e624c0dabe8ab76932635c72dab675a196 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -623,50 +646,56 @@ public class Docx4jPrinter {
                     Text t = factory.createText();
                     t.setValue("X");
                     r.getContent().add(t);
                     imgP.getContent().add(r);
                 } else if (shapeData != null && !shapeData.isBlank()) {
                     BufferedImage img = createOptionShapeImage(shapeData);
                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
                     ImageIO.write(img, "PNG", baos);
                     R r = factory.createR();
                     addImageToRunWithSize(pkg, r, baos.toByteArray(), "opt_" + label + ".png", 120, 100);
                     imgP.getContent().add(r);
                 }
 
                 imgCell.getContent().add(imgP);
                 imageRow.getContent().add(imgCell);
 
                 // Label cell with matching width
                 Tc labelCell = factory.createTc();
                 
                 // Set matching cell width
                 TcPr labelCellPr = factory.createTcPr();
                 TblWidth labelCellWidth = factory.createTblWidth();
                 labelCellWidth.setType("dxa");
                 labelCellWidth.setW(BigInteger.valueOf(1800)); // Same width as image cell
                 labelCellPr.setTcW(labelCellWidth);
+
+                // Center vertically for better alignment
+                TcPrInner.VAlign labelVAlign = factory.createTcPrInnerVAlign();
+                labelVAlign.setVal(STVerticalJc.CENTER);
+                labelCellPr.setVAlign(labelVAlign);
+
                 labelCell.setTcPr(labelCellPr);
                 
                 P labelP = factory.createP();
                 PPr labelPPr = factory.createPPr();
                 
                 // Center alignment
                 Jc labelJc = factory.createJc();
                 labelJc.setVal(JcEnumeration.CENTER);
                 labelPPr.setJc(labelJc);
                 
                 // Spacing: Vor 0pt, Nach 3pt, Einfach
                 PPrBase.Spacing labelSpacing = factory.createPPrBaseSpacing();
                 labelSpacing.setBefore(BigInteger.valueOf(0));   // 0pt
                 labelSpacing.setAfter(BigInteger.valueOf(60));   // 3pt = 60 twips
                 labelSpacing.setLine(BigInteger.valueOf(240));   // Single line spacing = 240 twips
                 labelSpacing.setLineRule(STLineSpacingRule.AUTO);
                 labelPPr.setSpacing(labelSpacing);
                 
                 labelP.setPPr(labelPPr);
                 
                 R lr = factory.createR();
                 
                 // Make labels bold
                 RPr labelRPr = factory.createRPr();
                 BooleanDefaultTrue labelBold = factory.createBooleanDefaultTrue();
 
EOF
)