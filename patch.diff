 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index ba4d10dc94dc71639b8e59b985876cf11478cf1c..60d32f12463592e0a9e834cbf4f289b4e9c1c142 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -1,47 +1,49 @@
 package docx;
 
 import org.docx4j.openpackaging.exceptions.Docx4JException;
 import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
 import org.docx4j.wml.*;
 import org.docx4j.dml.wordprocessingDrawing.Inline;
 import org.docx4j.openpackaging.parts.WordprocessingML.BinaryPartAbstractImage;
 
 import javax.swing.table.DefaultTableModel;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import java.util.*;
 import java.math.BigInteger;
 import java.awt.image.BufferedImage;
 import java.awt.geom.AffineTransform;
 import javax.imageio.ImageIO;
 import java.io.ByteArrayOutputStream;
 import java.awt.Graphics2D;
 import java.awt.RenderingHints;
 import java.awt.BasicStroke;
 import java.awt.Shape;
+import java.awt.Color;
+import org.locationtech.jts.io.WKTReader;
 
 // Import geometry classes for Figuren questions
 import org.locationtech.jts.geom.Geometry;
 import org.locationtech.jts.geom.Envelope;
 import org.locationtech.jts.awt.ShapeWriter;
 
 /**
  * Utility class using docx4j to generate print documents. This is a very
  * small proof of concept and does not cover the entire functionality of
  * the original Apache POI implementation.
  */
 public class Docx4jPrinter {
 
     private final ObjectFactory factory = new ObjectFactory();
 
     /**
      * Load the introduction pages and split them by page breaks.
      */
     public java.util.List<java.util.List<Object>> loadIntroductionPages(File docx) throws Docx4JException {
         WordprocessingMLPackage pkg = WordprocessingMLPackage.load(docx);
         java.util.List<Object> content = pkg.getMainDocumentPart().getContent();
         java.util.List<java.util.List<Object>> pages = new ArrayList<>();
         java.util.List<Object> current = new ArrayList<>();
         for (Object o : content) {
             current.add(o);
diff --git a/src/main/java/docx/Docx4jPrinter.java b/src/main/java/docx/Docx4jPrinter.java
index ba4d10dc94dc71639b8e59b985876cf11478cf1c..60d32f12463592e0a9e834cbf4f289b4e9c1c142 100644
--- a/src/main/java/docx/Docx4jPrinter.java
+++ b/src/main/java/docx/Docx4jPrinter.java
@@ -387,68 +389,183 @@ public class Docx4jPrinter {
                 AffineTransform transform = new AffineTransform();
                 
                 // Scale to fit with better proportions
                 Envelope shapeBounds = shape.getEnvelopeInternal();
                 double scaleX = (shapeSpacing * 0.7) / shapeBounds.getWidth(); // More compact horizontally
                 double scaleY = (imageHeight * 0.8) / shapeBounds.getHeight();
                 double scale = Math.min(scaleX, scaleY);
                 
                 // Center the shape in its allocated space
                 double centerX = (shapeBounds.getMinX() + shapeBounds.getMaxX()) / 2.0;
                 double centerY = (shapeBounds.getMinY() + shapeBounds.getMaxY()) / 2.0;
                 
                 transform.translate(currentX - centerX * scale, 
                                    imageHeight / 2.0 - centerY * scale);
                 transform.scale(scale, scale);
                 
                 // Add slight randomness for hand-drawn effect
                 java.util.Random random = new java.util.Random(shape.hashCode()); // Consistent randomness per shape
                 double offsetX = (random.nextDouble() - 0.5) * 2.0; // Small random offset
                 double offsetY = (random.nextDouble() - 0.5) * 2.0;
                 transform.translate(offsetX, offsetY);
                 
                 // Draw the shape with hand-drawn appearance
                 Shape awtShape = shapeWriter.toShape(shape);
                 Shape transformedShape = transform.createTransformedShape(awtShape);
+                g2d.setColor(new Color(200, 200, 200));
+                g2d.fill(transformedShape);
+                g2d.setColor(Color.BLACK);
                 g2d.draw(transformedShape);
                 
                 currentX += shapeSpacing;
             } catch (Exception e) {
                 System.out.println("Error drawing shape: " + e.getMessage());
             }
         }
         
         g2d.dispose();
         return image;
     }
+
+    /**
+     * Create an image for a single option shape using grey fill and black outline.
+     */
+    private BufferedImage createOptionShapeImage(String wkt) throws Exception {
+        Geometry geometry = new WKTReader().read(wkt);
+
+        int width = 300;
+        int height = 240;
+        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+        Graphics2D g2d = image.createGraphics();
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
+        g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
+
+        g2d.setColor(Color.WHITE);
+        g2d.fillRect(0, 0, width, height);
+
+        ShapeWriter writer = new ShapeWriter();
+        Envelope env = geometry.getEnvelopeInternal();
+        double scaleX = width / env.getWidth();
+        double scaleY = height / env.getHeight();
+        double scale = Math.min(scaleX, scaleY) * 0.9;
+
+        AffineTransform at = new AffineTransform();
+        at.translate(width / 2.0, height / 2.0);
+        at.scale(scale, -scale);
+        at.translate(-env.centre().x, -env.centre().y);
+
+        Shape shape = writer.toShape(geometry);
+        Shape ts = at.createTransformedShape(shape);
+        g2d.setColor(new Color(200, 200, 200));
+        g2d.fill(ts);
+        g2d.setColor(Color.BLACK);
+        g2d.setStroke(new BasicStroke(2.0f));
+        g2d.draw(ts);
+
+        g2d.dispose();
+        return image;
+    }
+
+    /**
+     * Add Figuren option images in a two-row table (images above labels).
+     */
+    private void addFigurenOptionsImages(WordprocessingMLPackage pkg, Object figurenOptionsData) {
+        try {
+            java.lang.reflect.Field optionsField = figurenOptionsData.getClass().getField("options");
+            @SuppressWarnings("unchecked")
+            java.util.List<Object> options = (java.util.List<Object>) optionsField.get(figurenOptionsData);
+            if (options == null || options.isEmpty()) {
+                return;
+            }
+
+            Tbl table = factory.createTbl();
+            Tr imageRow = factory.createTr();
+            Tr labelRow = factory.createTr();
+
+            for (Object opt : options) {
+                String label = String.valueOf(opt.getClass().getMethod("getLabel").invoke(opt));
+                String text = String.valueOf(opt.getClass().getMethod("getText").invoke(opt));
+                String shapeData = (String) opt.getClass().getMethod("getShapeData").invoke(opt);
+
+                // Image cell
+                Tc imgCell = factory.createTc();
+                P imgP = factory.createP();
+
+                if ("X".equals(text) || "E".equalsIgnoreCase(label)) {
+                    R r = factory.createR();
+                    Text t = factory.createText();
+                    t.setValue("X");
+                    r.getContent().add(t);
+                    imgP.getContent().add(r);
+                } else if (shapeData != null && !shapeData.isBlank()) {
+                    BufferedImage img = createOptionShapeImage(shapeData);
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    ImageIO.write(img, "PNG", baos);
+                    R r = factory.createR();
+                    addImageToRun(pkg, r, baos.toByteArray(), "opt_" + label + ".png");
+                    imgP.getContent().add(r);
+                }
+
+                imgCell.getContent().add(imgP);
+                imageRow.getContent().add(imgCell);
+
+                // Label cell
+                Tc labelCell = factory.createTc();
+                P labelP = factory.createP();
+                R lr = factory.createR();
+                Text lt = factory.createText();
+                lt.setValue(label + ")");
+                lr.getContent().add(lt);
+                labelP.getContent().add(lr);
+                labelCell.getContent().add(labelP);
+                labelRow.getContent().add(labelCell);
+            }
+
+            table.getContent().add(imageRow);
+            table.getContent().add(labelRow);
+            pkg.getMainDocumentPart().addObject(table);
+        } catch (Exception e) {
+            System.out.println("Could not add Figuren option images: " + e.getMessage());
+        }
+    }
     
     /**
      * Add question options from the table model with horizontal layout and proper A-E labels.
      */
     private void addQuestionOptions(WordprocessingMLPackage pkg, DefaultTableModel model, int startRow) {
         // Look for options in subsequent rows
         int currentRow = startRow + 1;
+
+        if (currentRow < model.getRowCount()) {
+            Object optObj = model.getValueAt(currentRow, 1);
+            if (optObj != null && optObj.getClass().getSimpleName().equals("FigurenOptionsData")) {
+                addFigurenOptionsImages(pkg, optObj);
+                return;
+            }
+        }
+
         java.util.List<String> optionTexts = new ArrayList<>();
         
         // Collect all options first
         while (currentRow < model.getRowCount()) {
             Object rowIdentifier = model.getValueAt(currentRow, 0);
             if (rowIdentifier != null && !rowIdentifier.toString().trim().isEmpty() && 
                 !rowIdentifier.toString().matches("\\d+")) {
                 // This looks like an option
                 Object optionObj = model.getValueAt(currentRow, 1);
                 if (optionObj != null) {
                     String optionText;
                     if (optionObj.getClass().getSimpleName().equals("FigurenOptionsData")) {
                         try {
                             // Use reflection to access option data
                             java.lang.reflect.Field optionsField = optionObj.getClass().getField("options");
                             @SuppressWarnings("unchecked")
                             java.util.List<Object> options = (java.util.List<Object>) optionsField.get(optionObj);
                             if (options != null && !options.isEmpty()) {
                                 optionText = "[Figur Option]";
                             } else {
                                 optionText = optionObj.toString();
                             }
                         } catch (Exception e) {
                             optionText = optionObj.toString();
                         }
 
EOF
)